<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MWEMU Docs</title>
  <link rel="icon" type="image/png" href="pics/favicon.png">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="sidebar">
    <h2>MWEMU Docs</h2>
    <ul>
        <li>
            <a href="#intro">1. MWEMU Intro</a>
            <ul>
                <li><a href="#whatis">1.1. what is mwemu</a></li>
                <li><a href="#ways">1.2. three ways of using it</a></li>
                <li><a href="#archs">1.3. architectures</a></li>
                <li><a href="#internals">1.4. internals overview</a></li>
                <li><a href="#test">1.5. test system</a></li>
                <li><a href="#contrib">1.6. contributors</a></li>
                <li><a href="#videos">1.7. videos</a></li>
                <li><a href="#license">1.8. license</a></li>
            </ul>
        </li>
        <li>
            <a href="#cmdline">2. Commandline</a>
            <ul>
                <li><a href="#cmdline_install">2.1. install</a></li>
                <li><a href="#help">2.2. --help</a></li>
                <li><a href="#fullemu">2.3. full emulation</a></li>
                <li><a href="#moment">2.4. capturing a moment</a></li>
                <li><a href="#verbosity">2.5. verbosity</a></li>
                <li><a href="#log">2.6. logging</a></li>
                <li><a href="#initreg">2.7. initialize registers</a></li>
                <li><a href="#regtrace">2.8. trace registers</a></li>
                <li><a href="#memtrace">2.9. trace memory</a></li>
                <li><a href="#strtrace">2.10. trace string</a></li>
                <li><a href="#calltrace">2.11. trace calls</a></li>
                <li><a href="#stacktrace">2.12 trace stack</a></li>
                <li><a href="#console">2.13. interactive console</a></li>
                <ul>
                    <li><a href="#helpcmd">2.13.1. help command</a></li>
                    <li><a href="#regcmd">2.13.2. registers command</a></li>
                    <li><a href="#mapscmd">2.13.3. maps command</a></li>
                    <li><a href="#mncmd">2.13.4. get map from addr</a></li>
                    <li><a href="#searchcmd">2.13.5. search command</a></li>
                    <li><a href="#bpcmd">2.13.6. break point commands</a></li>
                    <li><a href="#svcmd">2.13.7. change verbosity</a></li>
                    <li><a href="#ldrcmd">2.13.8. view LDR</a></li>
                    <li><a href="#dtcmd">2.13.9. view structures</a></li>
                    <li><a href="#viewcmd">2.13.10. view data</a></li>
                    <li><a href="#dumpcmd">2.13.11. dump maps to disk</a></li>
                    <li><a href="#r2cmd">2.13.12. radare2 command</a></li>
                </ul>
            </ul>
        </li>
        <li>
            <a href="#pymwemu">3. MWEMU from python scripts</a>
            <ul>
                <li><a href="#pyinstall">3.1. pymwemu instalation</a></li>
                <li><a href="#pyconfigure">3.2. instantiate and configure emulator</a></li>
                <li><a href="#pymaps">3.3. loading maps</a></li>
                <li><a href="#pyload">3.4. loading ELF PE or shellcodes</a></li>
                <li><a href="#pybuffers">3.5. creating buffers</a></li>
                <li><a href="#pycontext">3.6. prepare context</a></li>
                <li><a href="#pyemu">3.7. start emulation</a></li>
            </ul>
        </li>
        <li>
            <a href="#libmwemu">4. MWEMU from Rust apps</a>
            <ul>
                <li><a href="#crateinstall">4.1. rust crate instalation</a></li>
                <li><a href="#crateinstance">4.2. instance emu object</a></li>
                <li><a href="#crateload">4.3. loading ELF PE or shellcodes</a></li>
                <li><a href="#cratecontext">4.4. prepare context</a></li>
                <li><a href="#crateemu">4.5. start emulation</a></li>
            </ul>
        </li>
    </ul>
  </div>

  <div class="content">
    <section id="intro">
      <h1 class="mwemu">MWEMU Documentation.</h1>
      <h1>Intro</h1>
      <p>Welcome to official MWEMU documentation, you can do scrolling down or using the direct links that are on the left.</p>
      <p>Github repo: <a target="_blank" href="https://github.com/sha0coder/mwemu">https://github.com/sha0coder/mwemu</a></p>
      <p><img src="pics/mwemu_logo.png" width="60%"></p>
    </section>

        <section id="whatis">
          <h2>What is MWEMU?</h2>
          <p>MWEMU is a hardware emulator and Windows process simulator written in pure Rust from scratch, It was created by @sha0coder and It's open source. The contributors of this software have improved the quality of the project a lot, check <a href="#contrib"></a> to know them.<p>
          <p>The implemented hardware is x86/x64, unlike other emulators also implemt some parts of the OS (mainly windows) because asm code soon or later is going to do system calls (WinAPI, linux syscalls, etc).</p>
          <p>It resulted extremely useful for malware deobfuscation, but this don't replace reversing, I't needed a previous reversing to prepare well the emulation initial state, and emulate only small group of functions, like decryption, keygen etc. In some specific cases mwemu can do full-emulation, wihth simple packers, encoded shellcodes, etc.</p>
          <p>The emulation and simulation is implemented from scratch, but the awesome Rust library iced-x86 is used to the translation from a bunch of bytes to instruction objects. I implemented more than 300 x86 instructions, flags, exceptions, some loaders PE32/PE64/ELF64/shellcode32/shellcode64 and many other stuff.</p>
          <p>MWEMU is blazing fast and also is memory-safe thanks to the Rust magic compiler.</p>
        </section>

        <section id="ways">
          <h2>The 3 ways of using MWEMU</h2>
          <p>1. The first way is commandline, see <a href="#commandline">commandline</a> for more details, this is for trying full-emulation.</p>
          <p>2. Second way is creating python scripts with pymwemu module, can be installed with pip or git.</p>
          <p>pypi: <a target="_blank" href="https://pypi.org/project/pymwemu/">https://pypi.org/project/pymwemu/</a></p>
          <p>If you need features or bug-fixes implemented recently use the git, will need to compile the full project and then the python bindings with maturin, more details in this section <a target="_blank" href="#pyinstall">pymwemu instalation</a></p>
          <p>3. Third way is using the rust crate published in crates.io <a target="_blank" href="https://crates.io/crates/libmwemu">https://crates.io/crates/libmwemu</a> from a rust application.</p>
        </section>

        <section id="archs">
          <h2>Architectures</h2>
          <p>You can run MWEMU from Windows, Linux and Mac (x86 and also m1)</p>
          <p>But only can be emulated x86 code (32bits and 64bits) mainly for Windows, there is linux shellcode support even syscalls are implemented but regarding ELF only 64bits, only static compiled and quite basic support for now, but no problem with shellcodes.</p>
          <p>libc can be emulated well despite it is plenty of ymm instructions, but the linker cannot be emulated totally so far, my plan is fully emulating the linker, in this case I don't need to implement the hole linking process (.got and .plt creation etc)</p>
        </section>

        <section id="internals">
          <h2>A bit of internals</h2>
          <p>For now, just a basic overview of the internals.</p>
          <p><img src="pics/arch.png" width="120%"></p>
          <p>In the past I named the project SCEMU, and was stored in 3 separated repos for mwemu (the commandline) pymwemu (pyhon module) and (libmwemu) the engine where all is implemented and also it's the Rust Crate module on crates.io.</p>
          <p>Then it was renamed to MWEMU, because SCEMU is more specific to shellcode and because it's an italian bad word.</p>
          <p>So, now it's one repo with a crates/ folder with the 3 crates.</p>
          <p>The tests are implemented on crates/libmwemu/src/tests/ and are described lately.</p>
          <p>Most of files were splitted in small files.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ~/s/mwemu ❯❯❯ ls crates/libmwemu/src/                                main ⬆ ✱
banzai.rs       emu/               kuser_shared.rs  syscall/
breakpoint.rs   emu_context.rs     lib.rs           tests/
colors.rs       engine/            macros.rs        thread_context.rs
config.rs       err.rs             maps/            threading.rs
console.rs      exception.rs       ntapi/           tools/
constants.rs    exception_type.rs  pe/              tracing.rs
context/        flags.rs           peb/             utils.rs
crit_state.rs   fpu/               regs64.rs        winapi/
definitions.rs  fpu.rs             script.rs
eflags.rs       global_locks.rs    serialization/
elf/            hooks.rs           structures/
              </code></pre>
            </figure>
          </p>
          <p>emu/ contains emu methods and sub-bojects that are involved in the emulation itself.</p>
          <p>In engine/ there are the implementation of all the instructions.</p>
          <p>winapi/ contains the WinAPI implemntations divided in winapi32/ and winapi64/</p>
          <p>there are other thigngs like contants.rs structures/ etc.</p>
        </section>

        <section id="test">
          <h2>Test System</h2>
          <p>For triggering locally use <code>make tests</code> this downloads some binaries and launch the test system <code>cargo test</code></p>
          <p>Don't use --release, always is more convinient do the tests without aplying the optimizations, that could ignore some type of errors. Actually the github CI is configured to do cargo test and also cargo test --release to check both modes.</p>
          <p>Every git push or pull-request will trigger the CI in gibhut to perform all the tests in Linux, Windows and Mac. In in the case of PR is mandatory, in the case of a git push is only informative.</p>
          <p>PR also triggers a coverage analysis of the tests, which is currently only 32%</p>
          <p><img src="pics/tests.png" width="120%"></p>
        </section>

        <section id="contrib">
          <h2>Project Contributtors</h2>
          <p><a target="_blank" href="https://github.com/brandonros">Brandon Ros</a></p>
          <p><a target="_blank" href="https://github.com/acheron2302">Archeron2302</a></p>
          <p><a target="_blank" href="https://github.com/ElCapor">ElCapor</a></p>
          <p>There are also other people that suggested intereting ideas and optimizations.</p>
          <p>Regarding wit00 it's a github glitch for git pushing having a bad configuration in git config. (the bug was reported to github)</p>
          <p>I'm <a target="_blank" href="https://github.com/sha0coder">@sha0coder</a> and I created this software to empower my reversing engineering works, and I'm sharing this because I think it's useful for some cases.</p>
          <p>Some graphs:<a target="_blank" href="https://github.com/sha0coder/mwemu/graphs/contributors">https://github.com/sha0coder/mwemu/graphs/contributors</a>
        </section>

        <section id="Videos">
          <h2>Videos and pics</h2>
          <p><a target="_blank" href="https://www.youtube.com/watch?v=-TFL-_-nIqA">radare2 integration on mwemu - r2con2025</a></p>
          <p><a target="_blank" href="https://www.youtube.com/@JesusOlmos-wm8ch/videos">my youtube channel, there are some demos</a></p>
          <p><a target="_blank" href="https://x.com/noconname/status/1783878216458842312">zloader emulation - NcNLabs2022</a></p>
          <p><a target="_blank" href="https://www.youtube.com/watch?v=kfNWylFc6oY">Fixing FPU emulation</a></p>
        </section>

        <section id="license">
          <h2>License</h2>
          <p>Actually there are several licenses, the source code is GPLv3, but the crates.io rust module and pypi python module are MIT for having less restrictions in distributing software using libmwemu or pymwemu.</p>
          <p><a target="_blank" href="https://github.com/sha0coder/mwemu/blob/main/LICENSE">https://github.com/sha0coder/mwemu/blob/main/LICENSE</a></p>
          <p>Don't hesitate in contact me for creating technologies based of this software.</p>
          <p>email: sha0 at badchecksum dot net</p>
        </section>

    <section id="cmdline">
      <h1>MWEMU commandline tool</h1>
      <p>The commandline is a quick way of using mwemu, and there are many features like register/memory/call/string tracing or capturing emulation moments.</p>
      <p>If the packer is simple probably can be full-emulated using the commandline tool, but if you need more control use pymwemu and for total control libmwemu.</p>
      <p>In rust you can compile and exec together with cargo run, use --release mode for faster execution, example:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f file -vv -c 100
              </code></pre>
            </figure>
          </p>
        <p>This is equivalent of doing:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo build --release
               ❯❯❯ target/release/mwemu -6 -f file -vv -c 100
              </code></pre>
            </figure>
          </p>
    </section>

        <section id="cmdline_install">
          <h2>MWEMU Installation</h2>
          <p>1. First you need to install Rust and Cargo, and the best way is using rustup.</p>
          <p><a target="_blank" href="https://rustup.rs/">https://rustup.rs/</a></p>
          <p>For instance in linux or mac:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
                curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
              </code></pre>
            </figure>
          </p>
          <p>In the default setup binaries are in ~/.cargo/bin/ but you need to add this to the path, ideally on last section of the path.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
                export PATH="$PATH:/home/username/.cargo/bin/"
              </code></pre>
            </figure>
          </p>
          <p>The installer says how to put in the bashrc or other shells rc.</p>

            
          <p>2. Then there are 2 options to install this</p>
         <ul>
            <li>
                <p>Install from crates.io (is more convininent second option)</p>
                <p>
                <figure class="shell-block">
                  <figcaption>Shell</figcaption>
                  <pre><code>
                    cargo install mwemu 
         </code></pre>
                </figure>
                </p>
            </li>
            <li>
          <p>The recommended way is cloning the github repo and compile from it, with Cargo it's simple.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
                git clone https://github.com/sha0coder/mwemu.git
                cargo build --release
                make tests
              </code></pre>
            </figure>
          </p>
            </li>
        </ul>
        </section>

        <section id="help">
            <h2>--help</h2>
            <p>Use help option for viewing the commandline options, note that the before the "--" there are cargo flags and after the "--" are the parameters of the program, in this case mwemu commandline.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ~/s/mwemu ❯❯❯ cargo run --release -- --help                                                                                                        Finished `release` profile [optimized] target(s) in 0.06s
Running `target/release/mwemu --help`
MWEMU emulator for malware 0.7.12
@sha0coder

USAGE:
    mwemu [FLAGS] [OPTIONS]

FLAGS:
    -6, --64bits             enable 64bits architecture emulation
        --banzai             skip unimplemented instructions, and keep up emulating what can be emulated
        --call               enable call tracer
        --entropy            display changes in the entropy
        --flags              trace the flags hex value in every instruction.
    -F, --fpu                trace the fpu states.
    -h, --handle             handle Ctrl+C to spawn console
        --help               Prints help information
    -l, --loops              show loop interations, it is slow.
        --multithread        enable multithread emulation
    -n, --nocolors           print without colors for redirecting to a file &gt;out
    -p, --stack_trace        trace stack on push/pop
    -t, --test               test mode
    -m, --trace_memory       trace all the memory accesses read and write.
    -r, --trace_registers    print the register values in every step.
        --version            Prints version information
    -v, --verbose            -vv for view the assembly, -v only messages, without verbose only see the api calls and
                             goes faster

OPTIONS:
    -A, --args <ARGS>                             provide arguments to the EXE like: --args '"aa" "bb"'
        --cmd <COMMAND>                           launch a console command
    -b, --base &lt;ADDRESS&gt;                          set base address for code
    -c, --console <NUMBER>                        select in which moment will spawn the console to inspect.
    -C, --console_addr &lt;ADDRESS&gt;                  spawn console on first eip = address
    -d, --dump <FILE>                             load from dump.
    -a, --entry &lt;ADDRESS&gt;                         entry point of the shellcode, by default starts from the beginning.
    -e, --exit <POSITION>                         exit position of the shellcode
    -f, --filename <FILE>                         set the shellcode binary file.
    -i, --inspect <DIRECTION>                     monitor memory like: -i 'dword ptr [ebp + 0x24]
    -L, --log &lt;LOG_FILENAME&gt;                      log output to file
    -M, --maps <PATH>                             select the memory maps folder
        --mxcsr <MXCSR>                           set mxcsr register
        --r10 <R10>                               set r10 register
        --r11 <R11>                               set r11 register
        --r12 <R12>                               set r12 register
        --r13 <R13>                               set r13 register
        --r14 <R14>                               set r14 register
        --r15 <R15>                               set r15 register
        --r8 <R8>                                 set r8 register
        --r9 <R9>                                 set r9 register
        --rax <RAX>                               set rax register
        --rbp <RBP>                               set rbp register
        --rbx <RBX>                               set rbx register
        --rcx <RCX>                               set rcx register
        --rdi <RDI>                               set rdi register
        --rdx <RDX>                               set rdx register
        --rflags <RFLAGS>                         set rflags register
        --rip <RIP>                               set rip register
        --rsi <RSI>                               set rsi register
        --rsp <RSP>                               set rsp register
    -x, --script &lt;SCRIPT&gt;                         launch an emulation script, see scripts_examples folder
        --stack_address &lt;ADDRESS&gt;                 set stack address
    -s, --string &lt;ADDRESS&gt;                        monitor string on a specific address
    -T, --trace_filename <TRACE_FILENAME>         output trace to specified file
    -R, --trace_register <REGISTER1,REGISTER2>    trace a specific register in every step, value and content
    -S, --trace_start <TRACE_START>               start trace at specified position
    -V, --verbose_at <NUMBER>
            start displaying assembly at specific position (is like -vv enabled in specific moment)
              </code></pre>
            </figure>
          </p>
            <p></p>
        </section>

        <section id="fullemu">
          <h2>Full Emulation</h2>
          <p>Main options are:</p>
          <ul>
              <li><p>-6 for 64bits mode (otherwise would be 32bits)</p></li>
              <li><p>-f for selecting file path.</p></li>
              <li><p>-vv for vieweing the emulated assembler. (emulation is faster with no verbosity, in this case only shows the api calls)</p></li>
          </ul>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv  
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/fullemu.png" width="120%"></p>
        </section>

        <section id="moment">
          <h2>Capturing a moment</h2>
          <p>MWEMU displays always the number of emulated instructions, and this is a unique identificator of a moment.</p>
          <p>The moment 1 is the first assembly instruction, if you add the flag -c 1 the emulator will stop before emulating instruction 1</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ~/s/mwemu ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1                                                           main ⬆ ✱
    Finished `release` profile [optimized] target(s) in 0.07s
     Running `target/release/mwemu -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1`
static elf64 detected.
Entry point pointing to .text 0x401000
-------
1 0x401000: inc   al
--- console ---
=&gt;
              </code></pre>
            </figure>
          </p>
          <p>The instruction 1 will not be colored, this means that that instruction is going to be emulated in next step.</p>
          <p>This spawns the console in that emulator state, and you can press enters to emulate steps or "h" command for viewing options.</p>
          <p>If verbose mode is not set, only WinAPI, syscalls etc will be displayed, but there will be also a number that represent the emulated instructions until that state.</p>
          <p>There is the option of stopping the emulator at specific address with uppercase "-C addr" but note that the address can be triggered multiple times and is not an unique identificator like the -c moment</p>
        </section>

        <section id="verbosity">
          <h2>Verbosity</h2>
          <p>There are 4 verbosity levels:</p>
          <ul>
              <li><p>0: Don't use any -v for minimum verbosity, only WinAPI calls and syscalls will be printed.</p></li>
              <li><p>1: Use -v for viewing also some messages like, polymorfic code detected etc.</p></li>
              <li><p>2: Use -vv for viewing also the assembly code, mwemu will print every assembly instruction, this makes slower the emulation.2: Use -vv for viewing also the assembly code, mwemu will print every assembly instruction, this makes slower the emulation.</p></li>
              <li><p>3: Use -vvv for also viewing every "rep" interaction, in instruction with rep prefix like "rep movzx" will print one line for every step of the rep loop.</p></li>
          </ul>
          <p>Use -V or --verbose_at for enabling verbose mode at specific point.</p>
          <p>The verbose mode is automatically enabled 100 instructions previous to the configured -c moment to stop.</p>
        </section>

        <section id="log">
            <h2>Logging</h2>
            <p>It's possible to redirect the output to a file, ie:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1 &gt; /tmp/log
              </code></pre>
            </figure>
          </p>
          <p>But note that colors are terminal escape bytes and will be logged making parsing more difficult, if you do cat /tmp/log you will see the colors but if you use an editor you will see those bytes</p>
          <p>It is more convinient using --log option for a clean logs.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1 --log /tmp/log
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="initreg">
            <h2>Initialize registers</h2>
            <p>There are some cases like emulating dlls or chunk of code that needs some initial values in the registers.</p>
            <p>The commandline tool allows to set registers using those options:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
        --mxcsr &lt;MXCSR&gt;                           set mxcsr register
        --r10 &lt;R10&gt;                               set r10 register
        --r11 &lt;R11&gt;                               set r11 register
        --r12 &lt;R12&gt;                               set r12 register
        --r13 &lt;R13&gt;                               set r13 register
        --r14 &lt;R14&gt;                               set r14 register
        --r15 &lt;R15&gt;                               set r15 register
        --r8 &lt;R8&gt;                                 set r8 register
        --r9 &lt;R9&gt;                                 set r9 register
        --rax &lt;RAX&gt;                               set rax register
        --rbp &lt;RBP&gt;                               set rbp register
        --rbx &lt;RBX&gt;                               set rbx register
        --rcx &lt;RCX&gt;                               set rcx register
        --rdi &lt;RDI&gt;                               set rdi register
        --rdx &lt;RDX&gt;                               set rdx register
        --rflags &lt;RFLAGS&gt;                         set rflags register
        --rip &lt;RIP&gt;                               set rip register
        --rsi &lt;RSI&gt;                               set rsi register
        --rsp &lt;RSP&gt;                               set rsp register
              </code></pre>
            </figure>
          </p>
          <p>But note that colors are terminal escape bytes and will be logged making parsing more difficult, if you do cat /tmp/log you will see the colors but if you use an editor you will see those bytes</p>
          <p>It is more convinient using --log option for a clean logs.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
              ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -c 1 --rax 0x123 --rbx 0x1337
        Finished `release` profile [optimized] target(s) in 0.08s
        Running `target/release/mwemu -6 -f test/elf64lin_cpu_arithmetics1.bin -c 1 --rax 0x123 --rbx 0x1337`
        static elf64 detected.
        Entry point pointing to .text 0x401000
        --- console ---
        =&gt;r rax
            rax: 0x123 291
        =&gt;r rbx
            rbx: 0x1337 4919
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="regtrace">
          <h2>Trace Registers</h2>
          <p>Use option -R &lt;registers to trace&gt; to trace some registers</p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -R rax,rsp
               ...
            57 0x4010a2: rcr   al,1
                58 rax: 0x82f61001 2197164033
                58 rsp: 0x7fffffffe270
            58 0x4010a4: rcr   ax,1
                59 rax: 0x82f60800 2197161984
                59 rsp: 0x7fffffffe270
            59 0x4010a7: rcr   eax,1
                60 rax: 0xc17b0400 3246064640
                60 rsp: 0x7fffffffe270
            60 0x4010a9: rcr   rax,1
                61 rax: 0x60bd8200 1623032320
                61 rsp: 0x7fffffffe270
            61 0x4010ac: rcr   al,cl
                62 rax: 0x60bd8200 1623032320
                62 rsp: 0x7fffffffe270
            62 0x4010ae: rcr   ax,cl
                63 rax: 0x60bd8200 1623032320
                63 rsp: 0x7fffffffe270
            63 0x4010b1: rcr   eax,cl
                64 rax: 0x60bd8200 1623032320
                64 rsp: 0x7fffffffe270
            64 0x4010b3: rcr   rax,cl
                65 rax: 0x60bd8200 1623032320
                65 rsp: 0x7fffffffe270
            65 0x4010b6: mov   eax,90909090h ; 0x90909090
                66 rax: 0x90909090 2425393296
                66 rsp: 0x7fffffffe270
            66 0x4010bb: mov   edx,90909090h ; 0x90909090
                67 rax: 0x90909090 2425393296
                67 rsp: 0x7fffffffe270
            67 0x4010c0: mov   ecx,0 ; 0x0
                68 rax: 0x90909090 2425393296
                68 rsp: 0x7fffffffe270
            68 0x4010c5: shrd  eax,edx,cl
                69 rax: 0x90909090 2425393296
                69 rsp: 0x7fffffffe270
            69 0x4010c8: ret ; ret-addr: 0x0 ret-value: 0x90909090
              </code></pre>
            </figure>
          </p>
          <p>You can trace one or multiple registers at same time with -R option but with no spaces between registers.</p>
        </section>

        <section id="memtrace">
          <h2>Trace Memory</h2>
          <p>There are 2 ways of tracing memory:</p>
          <ul>
              <li><p>-m for tracing all the memory read and writes. (optionally -S moment enable the tracer from specific moment)</p></li>
              <li><p>-i 'dword ptr [eax + 0x8]' inspect mode allows many expressions but not all the combinations.</p></li>
          </ul>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/sc32win_donut.bin -vv -m -c 494253 -S 490000
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/memtrace.png" width="80%"></p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/sc32win_donut.bin -vv -m -i 'qword ptr [rsp + 0x8]'
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/inspect.png" width="80%"></p>
        </section>

        <section id="strtrace">
          <h2>Trace String</h2>
          <p>having the address of the string to trace, use -s &lt;addr&gt; to trace it</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -vv  -s 0x329ec8
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/strtrace.png" width="80%"></p>
          <p>Doing full verbose of millions of instructions is slower than non verbose mode, so let's enable the verbose mode only when it's needed.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -s 0x329ec8 -V 191
              </code></pre>
            </figure>
          </p>
          <p>Other option is using tracers with no verbose mode.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -s 0x329ec8
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/strtrace2.png" width="80%"></p>
        </section>

        <section id="calltrace">
          <h2>Trace Function Calls</h2>
          <p>Following the call paths can be useful when combining emulation with static analysis to see where we are coming from.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
               ❯❯❯ cargo run --release -- -6 -f test/exe64win_enigma.bin --call
              </code></pre>
            </figure>
          </p>
          <p><img src="pics/calltrace.png" width="80%"></p>
          <p>In this case, it is more convinient not to use verbose mode.</p>
        </section>

        <section id="console">
          <h2>Interactive Console</h2>
          <p>With the option -c &lt;num&gt; mwemu stops the emulation when will reached that num of emulated instructions, then spawn a console.</p>
          <p>For instance, we don't want to emulate 102063765 instructions in verbose mode, It's faster not using verbose mode. The -c option will enable verbose mode and tracers 100 instructions before reaching that number, so when console is spawned we have some previous context.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
            ❯❯❯ cargo run --release -- -6 -f test/exe64win_enigma.bin -c 102063765
            dll_path: maps/maps64//ntdll.dll dll: ntdll.dll
            PE64 header detected.
            loading memory maps
            dll_path: maps/maps64//kernel32.dll dll: kernel32.dll
            dll_path: maps/maps64//kernelbase.dll dll: kernelbase.dll
            dll_path: maps/maps64//iphlpapi.dll dll: iphlpapi.dll
            dll_path: maps/maps64//ws2_32.dll dll: ws2_32.dll
            dll_path: maps/maps64//advapi32.dll dll: advapi32.dll
            dll_path: maps/maps64//comctl32.dll dll: comctl32.dll
            dll_path: maps/maps64//winhttp.dll dll: winhttp.dll
            dll_path: maps/maps64//wininet.dll dll: wininet.dll
            dll_path: maps/maps64//dnsapi.dll dll: dnsapi.dll
            dll_path: maps/maps64//shell32.dll dll: shell32.dll
            dll_path: maps/maps64//shlwapi.dll dll: shlwapi.dll
            dll_path: maps/maps64//kernel32.dll dll: kernel32.dll
            dll_path: maps/maps64//user32.dll dll: user32.dll
            dll_path: maps/maps64//advapi32.dll dll: advapi32.dll
            dll_path: maps/maps64//oleaut32.dll dll: oleaut32.dll
            dll_path: maps/maps64//gdi32.dll dll: gdi32.dll
            dll_path: maps/maps64//shell32.dll dll: shell32.dll
            dll_path: maps/maps64//version.dll dll: version.dll
            dll_path: maps/maps64//ole32.dll dll: ole32.dll
            IAT Bound.
            Delay load binding started ...
            delay load bound!
            entry point at 0x14072ce04
            base: 0x140000000
            102063740 0x14072d2ac: jne   000000014072D2A4h taken
            102063741 0x14072d2a4: xor   [rax],dl
                mem_trace: pos = 102063741 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cb value = 0x59 name = 'exe64win_enigma593000'
                mem_trace: pos = 102063741 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cb value = 0x54 name = 'exe64win_enigma593000'
            102063742 0x14072d2a6: inc   rax
            102063743 0x14072d2a9: dec   rcx
            102063744 0x14072d2ac: jne   000000014072D2A4h taken
            102063745 0x14072d2a4: xor   [rax],dl
                mem_trace: pos = 102063745 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cc value = 0x44 name = 'exe64win_enigma593000'
                mem_trace: pos = 102063745 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cc value = 0x49 name = 'exe64win_enigma593000'
            102063746 0x14072d2a6: inc   rax
            102063747 0x14072d2a9: dec   rcx
            102063748 0x14072d2ac: jne   000000014072D2A4h taken
            102063749 0x14072d2a4: xor   [rax],dl
                mem_trace: pos = 102063749 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cd value = 0x42 name = 'exe64win_enigma593000'
                mem_trace: pos = 102063749 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cd value = 0x4f name = 'exe64win_enigma593000'
            102063750 0x14072d2a6: inc   rax
            102063751 0x14072d2a9: dec   rcx
            102063752 0x14072d2ac: jne   000000014072D2A4h taken
            102063753 0x14072d2a4: xor   [rax],dl
                mem_trace: pos = 102063753 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4ce value = 0x43 name = 'exe64win_enigma593000'
                mem_trace: pos = 102063753 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4ce value = 0x4e name = 'exe64win_enigma593000'
            102063754 0x14072d2a6: inc   rax
            102063755 0x14072d2a9: dec   rcx
            102063756 0x14072d2ac: jne   000000014072D2A4h not taken
            102063757 0x14072d2b2: jmp   000000014072D2BBh
                mem_trace: pos = 102063758 rip = 14072d2bb op = read bits = 32 address = 0x14000303c value = 0x80 name = 'exe64win_enigma3000'
            102063758 0x14072d2bb: mov   edi,[rsi+3Ch] ; 0x80
                mem_trace: pos = 102063759 rip = 14072d2be op = read bits = 32 address = 0x140003110 value = 0x571000 name = 'exe64win_enigma3000'
            102063759 0x14072d2be: mov   edi,[rdi+rsi+90h] ; 0x571000
            102063760 0x14072d2c5: add   rdi,rsi
            102063761 0x14072d2c8: cmp   dword ptr [rdi+0Ch],0
                mem_trace: pos = 102063761 rip = 14072d2c8 op = read bits = 32 address = 0x14057400c value = 0x5722ac name = 'exe64win_enigma3000'
                cmp: 0x5722ac &gt; 0x0
            102063762 0x14072d2cc: je    000000014072D370h not taken
                mem_trace: pos = 102063763 rip = 14072d2d2 op = read bits = 32 address = 0x14057400c value = 0x5722ac name = 'exe64win_enigma3000'
            102063763 0x14072d2d2: mov   ecx,[rdi+0Ch] ; 0x5722ac
            102063764 0x14072d2d5: add   rcx,rsi
            -------
            102063765 0x14072d2d8: call  qword ptr [rbp+5960B4h]
            --- console ---
            =&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="helpcmd">
          <h2>Help Command</h2>
          <p>press h to see the available commands:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;h
            --- help ---
            q ...................... quit
            cls .................... clear screen
            h ...................... help
            s ...................... stack
            v ...................... vars
            sv ..................... set verbose level 0, 1 or 2
            r ...................... register show all
            r reg .................. show reg
            rc ..................... register change
            f ...................... show all flags
            fc ..................... clear all flags
            fz ..................... toggle flag zero
            fs ..................... toggle flag sign
            c ...................... continue
            b ...................... breakpoint list
            ba ..................... breakpoint on address
            bi ..................... breakpoint on instruction number
            bmr .................... breakpoint on read memory
            bmw .................... breakpoint on write memory
            bmx .................... breakpoint on execute memory
            bcmp ................... break on next cmp or test
            bc ..................... clear breakpoint
            n ...................... next instruction
            eip .................... change eip
            rip .................... change rip
            push ................... push dword to the stack
            pop .................... pop dword from stack
            fpu .................... fpu view
            md5 .................... check the md5 of a memory map
            seh .................... view SEH
            veh .................... view vectored execption pointer
            m ...................... memory maps
            ms ..................... memory filtered by keyword string
            ma ..................... memory allocs
            mc ..................... memory create map
            mn ..................... memory name of an address
            ml ..................... memory load file content to map
            mr ..................... memory read, speficy ie: dword ptr [esi]
            mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
            mwb .................... memory write bytes, input spaced bytes
            md ..................... memory dump
            mrd .................... memory read dwords
            mrq .................... memory read qwords
            mds .................... memory dump string
            mdw .................... memory dump wide string
            mdd .................... memory dump to disk
            mdda ................... memory dump all allocations to disk
            mt ..................... memory test
            r2 [addr] .............. spawn radare2 console if it's isntalled
            ss ..................... search string
            sb ..................... search bytes
            sba .................... search bytes in all the maps
            ssa .................... search string in all the maps
            ll ..................... linked list walk
            d ...................... dissasemble
            dt ..................... dump structure
            pos .................... print current position
            enter .................. step into
            tr ..................... trace reg
            trc .................... trace regs clear
            ldr .................... show ldr linked list
            iat .................... find api name in all iat's
            iatx ................... addr to api name
            iatd ................... dump the iat of specific module
            dump ................... dump current state to disk
            ---
            =&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="regcmd">
          <h2>Register Commands</h2>
          <p>Use r for viewing all the registers, or r [reg] to see specific register.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>

            =&gt;r rsp
                rsp: 0x329f40
            =&gt;r
                rax: 0x0 0
                rbx: 0x0 0
                rcx: 0x0 0
                rdx: 0x2f 47
                rsi: 0x0 0
                rdi: 0x0 0
                rsp: 0x329f40
                rbp: 0x329ff8
                rip: 0x3c006e
                r8 : 0x0 0
                r9 : 0x0 0
                r10: 0x0 0
                r11: 0x0 0
                r12: 0x0 0
                r13: 0x0 0
                r14: 0x0 0
                r15: 0x0 0
              </code></pre>
            </figure>
          </p>
          <p>
            <figure class="shell-block">
                <figcaption>mwemu console</figcaption>
                <pre><code>
            =&gt;rc rax
            command not found, type h
            =&gt;rc
            register name=&gt;rax
            value=&gt;0x1337
            =&gt;r rax
                rax: 0x1337 4919
            =&gt;
                </code></pre>
            </figure>
          </p>
          <p>you can use 64bits and 32bits registers only, 16/8bits is not allowed for now ("r ax" or "r al")</p>
        </section>

        <section id="mapscmd">
          <h2>Maps Command</h2>
          <p>press m to list all the memory maps and addresses.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;m
            --- maps ---
            oleaut32.data       0x7ff001dc7000 - 0x7ff001dca000 (12288)
            ldr                 0x7ff000000000 - 0x7ff0000000b4 (180)
            ntdll.pe            0x7ff000003000 - 0x7ff000004000 (4096)
            kernelbase.text     0x7ff0002b6000 - 0x7ff0003c8000 (1122304)
            ws2_32.didat        0x7ff00060f000 - 0x7ff000610000 (4096)
            advapi32.pe         0x7ff000623000 - 0x7ff000624000 (4096)
            winhttp.text        0x7ff000960000 - 0x7ff000a0f000 (716800)
            iphlpapi.text       0x7ff00057f000 - 0x7ff0005a8000 (167936)
            version.rsrc        0x7ff001e0c000 - 0x7ff001e0d000 (4096)
            dnsapi.rdata        0x7ff000d6d000 - 0x7ff000d8f000 (139264)
            kernelbase.rsrc     0x7ff000555000 - 0x7ff000556000 (4096)
            comctl32.dll.ldr    0x7fe00000a000 - 0x7fe00000a940 (2368)
            shell32.rsrc        0x7ff0012d8000 - 0x7ff001b1d000 (8671232)
            advapi32.reloc      0x7ff0006cb000 - 0x7ff0006cd000 (8192)
            advapi32.rdata      0x7ff00068a000 - 0x7ff0006bf000 (217088)
            wininet.rsrc        0x7ff000cbe000 - 0x7ff000cd7000 (102400)
            wininet.didat       0x7ff000cbd000 - 0x7ff000cbe000 (4096)
            dnsapi.didat        0x7ff000d99000 - 0x7ff000d9a000 (4096)
            ole32.pdata         0x7ff001f38000 - 0x7ff001f47000 (61440)
            exe64win_enigma3000 0x140003000 - 0x140593000 (5832704)
            user32.rsrc         0x7ff001c30000 - 0x7ff001d12000 (925696)
            comctl32.pdata      0x7ff0008f9000 - 0x7ff00090f000 (90112)
            oleaut32.text       0x7ff001d14000 - 0x7ff001da1000 (577536)
            kernelbase.data     0x7ff000540000 - 0x7ff000545000 (20480)
            winhttp.pdata       0x7ff000a3c000 - 0x7ff000a46000 (40960)
            ws2_32.rdata        0x7ff0005fd000 - 0x7ff00060a000 (53248)
            ...
              </code></pre>
            </figure>
          </p>
          <p>We can see map name, start address, end address and size in bytes.</p>
          <p>Other memory related commands:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            m ...................... memory maps
            ms ..................... memory filtered by keyword string
            ma ..................... memory allocs
            mc ..................... memory create map
            mn ..................... memory name of an address
            ml ..................... memory load file content to map
            mr ..................... memory read, speficy ie: dword ptr [esi]
            mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
            mwb .................... memory write bytes, input spaced bytes
            md ..................... memory dump
            mrd .................... memory read dwords
            mrq .................... memory read qwords
            mds .................... memory dump string
            mdw .................... memory dump wide string
            mdd .................... memory dump to disk
            mdda ................... memory dump all allocations to disk
            mt ..................... memory test
              </code></pre>
            </figure>
          <p></p>
        </section>

        <section id="mncmd">
          <h2>Get Map details from Address</h2>
          <p>if the code is using an address and you want more details, use command mn.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;mn
            address=&gt;0x140000008
            map: exe64win_enigma.pe 0x140000000-0x140001000 (4096)
            =&gt;
              </code></pre>
            </figure>
          </p>
          <p>Note that mwemu commands dont accept parameters direcly, first type the command + enter then the parameter will prompted.</p>
          <p>except for the r2 command that needs an address to spawn radare2, ie:  r2 0x140000008</p>
        </section>

        <section id="searchcmd">
          <h2>Search Commands</h2>
          <p>There are four commands to search.</p>
          <ul>
              <li><p>use command ss for search a string in a specific map.</p></li>
              <li><p>use command sb for search a sequence of spaced bytes in a specific map.</p></li>
              <li><p>use command ssa for search a string in all the maps.</p></li>
              <li><p>use command sba for search a sequence of spaced bytes in all the maps.</p></li>
          </ul>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;ssa  (search string in all the maps)
            string=&gt;http://something.com/
            found at 0x329ec8 'http://something.com/'
            found at 0x329fc8 'http://something.com/'
            map not found

            =&gt;mds (display string on an address)
            address=&gt;0x329ec8
            0x329ec8: 'http://something.com/'
            =&gt;mds
            address=&gt;0x329fc8
            0x329fc8: 'http://something.com/'
            =&gt; 

            =&gt;mn (which map is that address?)
            address=&gt;0x329ec8
            map: stack 0x22a000-0x32c000 (1056768)
            =&gt;mn
            address=&gt;0x329fc8
            map: stack 0x22a000-0x32c000 (1056768)
            =&gt;

            =&gt;ss (search string on specific address)
            map name=&gt;stack
            string=&gt;http://something.com/
            found 0x329ec8 'http://something.com/'
            found 0x329fc8 'http://something.com/'

            =&gt;sb (search spaced bytes on specific address, ie searching hexlified "http://")
            map name=&gt;stack
            spaced bytes=&gt;68 74 74 70 3a 2f 2f
            found at 0x329ec8
            found at 0x329fc8
            =&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="bpcmd">
          <h2>Breakpoint Commands</h2>
          <p>There are four types of breakpoints, but only one breakpoint can be set for each type at once.</p>
          <ul>
              <li><p>break on address, the next time this address is reached the emulation will stop there.</p></li>
              <li><p>break on instruction, when the emulator reach that number of instructions emulated in total, will stop there.</p></li>
              <li><p>break on memory read, next time this address is readed by any assembly instruction (not api or syscall) the emulator will break there.</p></li>
              <li><p>break on memory write, next write to this address (doesn't matter if is a 1-byte write or any amount) will stop the emulation.</p></li>
              <li><p>break on next cmp or test instruction, this will stop the emulator on next cmp or test instruction.</p></li>
          </ul>
          <p>Use command "b" to see the state of the 4 types of breakpoints.There are four commands to search.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;b
            break on address: []
            break on instruction: []
            break on memory read: []
            break on memory write: []
              </code></pre>
            </figure>
          </p>
          <p>Use these commands to set the breakpoints:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            b ...................... breakpoint list
            ba ..................... breakpoint on address
            bi ..................... breakpoint on instruction number
            bmr .................... breakpoint on read memory
            bmw .................... breakpoint on write memory
            bmx .................... breakpoint on execute memory
            bcmp ................... break on next cmp or test instruction
            bc ..................... clear breakpoint
              </code></pre>
            </figure>
          </p>
          <p>Some examples:</p>
          <p><img src="pics/bpcmp.png" width="80%"></p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            --- console ---
            =&gt;bi
            instruction number=&gt;100
            =&gt;c
            18 0x3c006a: jne   short 00000000003C004Ah taken
            19 0x3c004a: mov   rax,[rbp-8] ; 0x329f10
            20 0x3c004e: movzx edx,byte ptr [rax]
            21 0x3c0051: mov   rax,[rbp-10h] ; 0x329e10
            22 0x3c0055: mov   [rax],dl ; 0x68
            23 0x3c0057: add   qword ptr [rbp-8],1
            24 0x3c005c: add   qword ptr [rbp-10h],1
            25 0x3c0061: mov   rax,[rbp-8] ; 0x329f11
            ...
            96 0x3c0065: movzx eax,byte ptr [rax]
            97 0x3c0068: test  al,al
            98 0x3c006a: jne   short 00000000003C004Ah taken
            99 0x3c004a: mov   rax,[rbp-8] ; 0x329f18
            -------
            100 0x3c004e: movzx edx,byte ptr [rax]   (this instruction is the next to be emulated, it was not emulated yet)
            --- console ---
            =&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="svcmd">
          <h2>Change Verbosity</h2>
          <p>If you type the "sv" command, mwemu will ask you for the new verbosity level number, these are the possible verbose levels:</p>
          <ul>
              <li><p>0: It's like not using any -v for minimum verbosity, only WinAPI calls and syscalls will be printed.</p></li>
              <li><p>1: It's like using -v for viewing also some messages like, polymorfic code detected etc.</p></li>
              <li><p>2: It's like using -vv for viewing also the assembly code, mwemu will print every assembly instruction, this makes slower the emulation.2: Use -vv for viewing also the assembly code, mwemu will print every assembly instruction, this makes slower the emulation.</p></li>
              <li><p>3: It's like using -vvv for also viewing every "rep" interaction, in instruction with rep prefix like "rep movzx" will print one line for every step of the rep loop.</p></li>
          </ul>
          <p>For instance, we want to emulate quiclky the first 200 insturctions, and then enable the verbosity, this could be dont with -V, but let's do it from the console with "sv" command:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            ~/s/mwemu ❯❯❯ cargo run --release -- -6 -f test/sc64win_strgen.bin -c 200
            ...
            200 0x3c004e: movzx edx,byte ptr [rax]    (instruction 200 is not emulated yet, it's the next instruction to be emulated)
            --- console ---
            =&gt;sv
            verbose level=&gt;3
            =&gt; [enter for emulating instruction 200]
            =&gt; c  (continue emulating now with maximum verbosity) 
            ...
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="ldrcmd">
          <h2>View LDR</h2>
          <p>The LDR is a triple circular liked list that cointains all the linked modules (not only DLL, also EXE)</p>
          <p>MWEMU provides several commands to view and query the LDR.</p>
          <ul>
              <li><p>"ldr" command is the way of viewing the LDR contents.</p></li>
              <li><p>"iat" comamnd allows to find an specified api name in all the IAT's of every linked module.</p></li>
              <li><p>"iatx" If we have an address and we want to know which API name is, this command does the address to name query.</p></li>
              <li><p>"iatd" command dump the full IAT of a specified module.</p></li>
          </ul>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            --- console ---
            =&gt;ldr
            0x7fe000000000 loader.exe flink:7fe000004000 blink:7fe00000f000 base:7ff001b7e000 pe_hdr:f8 5045
            0x7fe000004000 ntdll.dll flink:7fe000005000 blink:7fe000000000 base:7ff000003000 pe_hdr:e8 5045
            0x7fe000005000 kernel32.dll flink:7fe000006000 blink:7fe000004000 base:7ff0001f8000 pe_hdr:f0 5045
            0x7fe000006000 kernelbase.dll flink:7fe000007000 blink:7fe000005000 base:7ff0002b5000 pe_hdr:f0 5045
            0x7fe000007000 iphlpapi.dll flink:7fe000008000 blink:7fe000006000 base:7ff00057e000 pe_hdr:f8 5045
            0x7fe000008000 ws2_32.dll flink:7fe000009000 blink:7fe000007000 base:7ff0005b8000 pe_hdr:f0 5045
            0x7fe000009000 advapi32.dll flink:7fe00000a000 blink:7fe000008000 base:7ff000623000 pe_hdr:100 5045
            0x7fe00000a000 comctl32.dll flink:7fe00000b000 blink:7fe000009000 base:7ff0006cd000 pe_hdr:f0 5045
            0x7fe00000b000 winhttp.dll flink:7fe00000c000 blink:7fe00000a000 base:7ff00095f000 pe_hdr:f8 5045
            0x7fe00000c000 wininet.dll flink:7fe00000d000 blink:7fe00000b000 base:7ff000a4f000 pe_hdr:f0 5045
            0x7fe00000d000 dnsapi.dll flink:7fe00000e000 blink:7fe00000c000 base:7ff000cd9000 pe_hdr:f8 5045
            0x7fe00000e000 shell32.dll flink:7fe00000f000 blink:7fe00000d000 base:7ff000da4000 pe_hdr:f0 5045
            0x7fe00000f000 shlwapi.dll flink:7fe000000000 blink:7fe00000e000 base:7ff001b2c000 pe_hdr:f0 5045
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="dtcmd">
          <h2>View Structures</h2>
          <p>The windows debugger windbg has a unique feature that is dt command to see information about structures, is quite useful and uniq.</p>
          <p>MWEMU implements a similar dt command but for specific structures, that could be useful in some situations.</p>
          <p>Let's use dt to inspect PEB structure.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;dt
            structure=&gt;peb
            address=&gt;0x7ffdf000
            PEB {
                reserved1: [
                    0x0,
                    0x0,
                ],
                being_debugged: 0x0,
                reserved2: 0x0,
                reserved3: [
                    0xffffffff,
                    0x400000,
                ],
                ldr: 0x77647880,
                process_parameters: 0x2c1118,
                reserved4: [
                    0x0,
                    0x2c0000,
                    0x77647380,
                ],
                alt_thunk_list_ptr: 0x0,
                reserved5: 0x0,
                reserved6: 0x6,
                reserved7: 0x773cd568,
                reserved8: 0x0,
                alt_thunk_list_ptr_32: 0x0,
                reserved9: [
                    0x0,
            ...
              </code></pre>
            </figure>
          </p>
          <p>Let's use dt to inspect PEB_LDR_DATA structure.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;dt
            structure=&gt;PEB_LDR_DATA
            address=&gt;0x77647880
            PebLdrData {
                length: 0x30,
                initializated: 0x1,
                sshandle: 0x0,
                in_load_order_module_list: ListEntry {
                    flink: 0x2c18b8,
                    blink: 0x2cff48,
                },
                in_memory_order_module_list: ListEntry {
                    flink: 0x2c18c0,
                    blink: 0x2cff50,
                },
                in_initialization_order_module_list: ListEntry {
                    flink: 0x2c1958,
                    blink: 0x2d00d0,
                },
                entry_in_progress: ListEntry {
                    flink: 0x0,
                    blink: 0x0,
                },
            }
            =&gt;
              </code></pre>
            </figure>
          </p>
          <p>Let's use dt to inspect LDR_DATA_TABLE_ENTRY structure, that represents one LDR entry in the linked list of a specific linked module.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            =&gt;dt
            structure=&gt;LDR_DATA_TABLE_ENTRY
            address=&gt;0x2c18c0
            LdrDataTableEntry {
                reserved1: [
                    0x2c1950,
                    0x77647894,
                ],
                in_memory_order_module_links: ListEntry {
                    flink: 0x0,
                    blink: 0x0,
                },
                reserved2: [
                    0x0,
                    0x400000,
                ],
                dll_base: 0x4014e0,
                entry_point: 0x1d000,
                reserved3: 0x40003e,
                full_dll_name: 0x2c1716,
                reserved4: [
                    0x0,
                    0x0,
                    0x0,
                    0x0,
                    0x0,
                    0x0,
                    0x0,
                    0x0,
                ],
                reserved5: [
                    0x17440012,
                    0x4000002c,
                    0xffff0000,
                ],
                checksum: 0x1d6cffff,
                reserved6: 0xa640002c,
                time_date_stamp: 0xcdf27764,
            }
            =&gt;
              </code></pre>
            </figure>
          </p>
          <p>Example: a malware is hiding something in an exception.</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            3307726 0x4f9673: push  ebp
            3307727 0x4f9674: push  edx
            3307728 0x4f9675: push  eax
            3307729 0x4f9676: push  ecx
            3307730 0x4f9677: push  ecx
            3307731 0x4f9678: push  4F96F4h
            3307732 0x4f967d: push  dword ptr fs:[0]
            Reading SEH 0x0
            -------
            3307733 0x4f9684: mov   eax,[51068Ch]
            --- console ---
            =&gt;
              </code></pre>
            </figure>
          </p>
          <p>Let's inspect exception structures:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            --- console ---
            =&gt;r esp
                    esp: 0x22de98
            =&gt;dt
            structure=&gt;cppeh_record
            address=&gt;0x22de98
            CppEhRecord {
                old_esp: 0x0,
                exc_ptr: 0x4f96f4,
                next: 0xfffffffe,
                exception_handler: 0xfffffffe,
                scope_table: PScopeTableEntry {
                    enclosing_level: 0x278,
                    filter_func: 0x51068c,
                    handler_func: 0x288,
                },
                try_level: 0x288,
            }
            =&gt;
              </code></pre>
            </figure>
          </p>
          <p>And here we have the error routine 0x4f96f4 and the filter 0x51068c.</p>
        </section>

        <section id="viewcmd">
          <h2>View Data</h2>
          <p>There are multiple commands to view data, but currently I'm using the "r2 addr" command which is better bot for code and data. Note that r2 command executes the radare2 and transfer the memory map of the selected address, and sync radare2 with mwemu, but this command needs to have installed radare2 in the path, for instance from the git. More details on <a href="#r2cmd">radare2</a> chapter. It worth to install radare2.</p>


          <p>Commands for displaying information:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            mr ..................... memory read, speficy ie: dword ptr [esi]
            mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
            mwb .................... memory write bytes, input spaced bytes
            md ..................... memory dump
            mrd .................... memory read dwords
            mrq .................... memory read qwords
            mds .................... memory dump string
            mdw .................... memory dump wide string
            mdd .................... memory dump to disk
            mdda ................... memory dump all allocations to disk
            mt ..................... memory test
              </code></pre>
            </figure>
          </p>
          <p>Example with md command:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            --- console ---
            =&gt;md
            address=&gt;0x329ec8
            0x329ec8: 68 74 74 70 3a 2f 2f 73 6f 6d 65 74 68 69 6e 67     http://something
            0x329ed8: 2e 63 6f 6d 2f 00 00 00 00 00 00 00 00 00 00 00     .com/...........
            0x329ee8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            0x329ef8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            0x329f08: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            0x329f18: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            0x329f28: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            0x329f38: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
            =&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="r2cmd">
          <h2>Radare2 Command</h2>
          <p>This command gives a lot of power to MWEMU because we can use radare2 from inside of a MWEMU emualtion moment.</p>

          <p>Note that this executes another program (also free software) named radare2 that has to be installed and accesible from the path.</p>
          <p><img src="pics/radare2.png" width=20%></p>
          <p>The instalation is simple I will explan it later.</p>
          <p>Spawning radare over a data address:</p>
          <p><img src="pics/r2_px.png" width=80%></p>
          <p>Using q to return form r2 prompt to mwemu prompt and spawn radare again with a code address:</p>
          <p><img src="pics/r2_code.png" width=80%></p>
          <p>Radare are recognizing functions and decompiling them with the multiple decompilers, even we can use decai for AI based decompiled in python etc.</p>
          <p>More info specific of radare commands check the r2book: <a href="https://book.rada.re/" target="_blank">https://book.rada.re/</a></p>
          <p>Regarding the radare2 installation:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
              ❯❯❯ git clone https://github.com/radareorg/radare2.git
              ❯❯❯ cd radare2
              ❯❯❯ sys/install.sh
              </code></pre>
            </figure>
          </p>
          <p>The install.sh script does all the installation, It will prompt sudo to copy binaries to folders that are on the path.</p>
          <p>If radare2 is in the path, It would be possible to trigger it from mwemu r2 command.</p>
        </section>

        <section id="pymwemu">
          <h1>MWEMU from python scripts</h1>
          <p>This is probably the most practical use-case of MWEMU, using the pymwemu python module.</p>
        </section>

        <section id="pyinstall">
          <h2>pymwemu Instalation</h2>
          <p>They easiest way to install this is using pip, the package is published at pypi <a href="https://pypi.org/project/pymwemu/" target="_blank">https://pypi.org/project/pymwemu/</a></p>
          <p>For using latest version use git, but it's more tricky to install, because you need rust, cargo and maturin.</p>
          <p>It's precompiled for linux 64bits, so in linux in theory you don't need to install rust first.</p>
          <p>In linux you just do:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            ❯❯❯ pip3 install pymwemu --break-system-packages
              </code></pre>
            </figure>
          </p>
          <p>In mac, windows or if the pip requires it, install first rust.</p>
          <p>Install rust from rustup, make sure cargo is on the path, and do pip or pip3:</p>
          <p>
            <figure class="shell-block">
              <figcaption>mwemu console</figcaption>
              <pre><code>
            ❯❯❯ pip install --upgrade pip
            ❯❯❯ pip3 install --upgrade pip
            ❯❯❯ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
            ❯❯❯ pip install pymwemu
            ❯❯❯ pip3 install pymwemu
              </code></pre>
            </figure>
          </p>
          <p>In mac, if there is a problem with !tapi-tbd the solution is:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
            ❯❯❯ sudo xcode-select --switch /Library/Developer/CommandLineTools
              </code></pre>
            </figure>
          </p>
          <p>To verify the installation we can import the module in python console.</p>
            <figure class="shell-block">
              <figcaption>Shell</figcaption>
              <pre><code>
            ❯❯❯ python3
            Python 3.13.5 (main, Jun 25 2025, 18:55:22) [GCC 14.2.0] on linux
            Type "help", "copyright", "credits" or "license" for more information.
            &gt;&gt;&gt; import pymwemu
            Initialized logging
            &gt;&gt;&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="pyconfigure">
          <h2>Instantiate and Configure the Emulator</h2>
          <p>First of all, import the module and init the 32bits or the 64bits engine.</p>
          <p>Then there are some initial configurations you can do detailed later.</p>
          <p>
            <figure class="shell-block">
              <figcaption>Python Console</figcaption>
              <pre><code>
            &gt;&gt;&gt; import pymwemu
            Initialized logging
            &gt;&gt;&gt; emu = pymwemu.init32() # or emu = pymwemu.init64()
            &gt;&gt;&gt; # then there are some initial configurations, for instance:
            &gt;&gt;&gt; emu.set_verbose(3)     # to show all the assembly, normally this is not needed. By default is 0 verbose.
            &gt;&gt;&gt; emu.enable_console()   # by default is disabled.
            &gt;&gt;&gt; emu.spawn_console_at_pos(6) # useful for debugging the script.
            loading memory maps
            &gt;&gt;&gt;
            &gt;&gt;&gt;
              </code></pre>
            </figure>
          </p>
          <p>All the configurations possible:</p>
          <ul>
                <li><p><code>emu.load_maps(folder:str)</code> set the maps32 or maps64 folder with all the libs.</p></li>
                <li><p><code>emu.load_binary(filename:str)</code> load the sample to be emulated:.</p></li>
                <li><p><code>emu.load_code_bytes(opcodes:bytes)</code> if you have the bytes already on python bytes() / bytearray()</p></li>
                <li><p><code>emu.load_map(name:str, filename:str, base_addr:int)</code> use this if you need to add extra modules</p></li>
          </ul>
        </section>

        <section id="pymaps">
          <h2>Loading Maps</h2>
          <p>In most of cases you will need to load all the Windows OS simulation part, to have all the PEB+TEB+LDR linkedlist and WinAPI infra.</p>
          <p>For doing this you can use <code>emu.load_maps(folder:str)</code></p>
          <p>If you are going to emulate pure assembly, with no api calls, and no access to windows structures, you don't need to load the maps.</p>
          <p>So does if you are emulating linux elf64 or shellcodes (remember, elf64 is not well suported for now)</p>
          <p>Example:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Python Console</figcaption>
              <pre><code>
            &gt;&gt;&gt; emu.load_maps('/home/sha0/src/mwemu/maps/maps64/')
            loading memory maps
            dll_path: /home/sha0/src/mwemu/maps/maps64//ntdll.dll dll: ntdll.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//kernel32.dll dll: kernel32.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//kernelbase.dll dll: kernelbase.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//iphlpapi.dll dll: iphlpapi.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//ws2_32.dll dll: ws2_32.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//advapi32.dll dll: advapi32.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//comctl32.dll dll: comctl32.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//winhttp.dll dll: winhttp.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//wininet.dll dll: wininet.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//dnsapi.dll dll: dnsapi.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//shell32.dll dll: shell32.dll
            dll_path: /home/sha0/src/mwemu/maps/maps64//shlwapi.dll dll: shlwapi.dll
            &gt;&gt;&gt;
              </code></pre>
            </figure>
          </p>
          <p>Note that this need to have the maps, so git clone the repo:</p>
          <p>
              <figure class="shell-block">
                <figcaption>Shell</figcaption>
                <pre><code>
                git clone https://github.com/sha0coder/mwemu.git 
                </code></pre>
            </figure>
          </p>
        </section>

        <section id="pyload">
          <h2>loading ELF, PE, or shellcodes</h2>
          <p></p>
          <ul>
              <li><p><code>emu.load_binary(filename:str)</code> load the sample to be emulated:.</p></li>
              <li><p><code>emu.load_code_bytes(opcodes:bytes)</code> if you have the bytes already on python bytes() / bytearray()</p></li>
          </ul>

          <p>Example:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Python Console</figcaption>
              <pre><code>
            &gt;&gt;&gt; emu.load_binary('shellcodes32/shikata.bin')
            &gt;&gt;&gt;
              </code></pre>
            </figure>
          </p>
        </section>

        <section id="pybuffers">
          <h2>Creating Buffers</h2>
          <p>You can load sections from disk to the emulator's virtual memory, and also can allocate buffers.</p>
          <ul>
              <li><p><code>emu.alloc(name:str, size:int) -&gt; int</code> allocate an space.</p></li>
              <li><p><code>emu.alloc_at(name:str, addr:int, size: int)</code> this allows you to reserve a buffer in a specific position.</p></li>
               <li><p><code>emu.load_map(name:str, filename:str, base_addr:int)</code> you can load extra sections from disk to specific addresses.</p></li>
          </ul>

          <p>Example:</p>
          <p>
            <figure class="shell-block">
              <figcaption>Python Console</figcaption>
              <pre><code>
            &gt;&gt;&gt; addr = emu.alloc("mybuffer", 1024)
            &gt;&gt;&gt;
              </code></pre>
            </figure>
          </p>
        </section>




        <section id="libmwemu">
          <h2>MWEMU for Rust apps</h2>
          <p>All is implemented in libmwemu, mwemu is just a flags parser that uses libmwemu, same with pyhon bindings on pymwemu, so having said that, from rust you can use all the power of MWEMU, and most of the objects are public so you have a good control of the emulator.</p>
          <p><a href="https://docs.rs/libmwemu/0.23.0/libmwemu/" target="_blank">https://docs.rs/libmwemu/0.23.0/libmwemu/</a></p>
          <p><a href="https://crates.io/crates/libmwemu" target="_blank">https://crates.io/crates/libmwemu</a></p>
        </section>

</div>
</body>
</html>




