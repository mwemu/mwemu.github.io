<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MWEMU Docs</title>
  <link rel="icon" type="image/png" href="pics/favicon.png">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="sidebar">
    <h2>MWEMU Docs</h2>
    <ul>
      <li>
        <a href="#intro">1. MWEMU Intro</a>
        <ul>
          <li><a href="#whatis">1.1. what is mwemu</a></li>
          <li><a href="#ways">1.2. three ways of using it</a></li>
          <li><a href="#archs">1.3. architectures</a></li>
          <li><a href="#internals">1.4. internals overview</a></li>
          <li><a href="#test">1.5. test system</a></li>
          <li><a href="#contrib">1.6. contributors</a></li>
          <li><a href="#videos">1.7. videos</a></li>
          <li><a href="#license">1.8. license</a></li>
        </ul>
      </li>
      <li>
        <a href="#cmdline">2. Commandline</a>
        <ul>
          <li><a href="#cmdline_install">2.1. install</a></li>
          <li><a href="#help">2.2. --help</a></li>
          <li><a href="#fullemu">2.3. full emulation</a></li>
          <li><a href="#moment">2.4. capturing a moment</a></li>
          <li><a href="#verbosity">2.5. verbosity</a></li>
          <li><a href="#log">2.6. logging</a></li>
          <li><a href="#initreg">2.7. initialize registers</a></li>
          <li><a href="#regtrace">2.8. trace registers</a></li>
          <li><a href="#memtrace">2.9. trace memory</a></li>
          <li><a href="#strtrace">2.10. trace string</a></li>
          <li><a href="#calltrace">2.11. trace calls</a></li>
          <li><a href="#stacktrace">2.12 trace stack</a></li>
          <li><a href="#console">2.13. interactive console</a></li>
          <ul>
            <li><a href="#helpcmd">2.13.1. help command</a></li>
            <li><a href="#regcmd">2.13.2. registers command</a></li>
            <li><a href="#mapscmd">2.13.3. maps command</a></li>
            <li><a href="#mncmd">2.13.4. get map from addr</a></li>
            <li><a href="#searchcmd">2.13.5. search command</a></li>
            <li><a href="#bpcmd">2.13.6. break point commands</a></li>
            <li><a href="#svcmd">2.13.7. change verbosity</a></li>
            <li><a href="#ldrcmd">2.13.8. view LDR</a></li>
            <li><a href="#dtcmd">2.13.9. view structures</a></li>
            <li><a href="#viewcmd">2.13.10. view data</a></li>
            <li><a href="#dumpcmd">2.13.11. dump maps to disk</a></li>
            <li><a href="#r2cmd">2.13.12. radare2 command</a></li>
          </ul>
        </ul>
      </li>
      <li>
        <a href="#pymwemu">3. PYMWEMU from python scripts</a>
        <ul>
          <li><a href="#pyinstall">3.1. pymwemu instalation</a></li>
          <li><a href="#pycompile">3.2. build pymwemu (only for devs)</a></li>
          <li><a href="#pycreate">3.3. create emulation object</a></li>
          <li><a href="#pyconfigure">3.4. configure emulator</a></li>
          <li><a href="#pymaps">3.5. loading maps</a></li>
          <li><a href="#pyload">3.6. loading ELF PE or shellcodes</a></li>
          <li><a href="#pybuffers">3.7. creating buffers</a></li>
          <li><a href="#pyregisters">3.8. registers</a></li>
          <li><a href="#pymemory">3.9. memory operations</a></li>
          <li><a href="#pystart">3.10. start emulation</a></li>
          <li><a href="#pystack">3.11. stack</a></li>
          <li><a href="#pybp">3.12. breakpoints</a></li>
          <li><a href="#pymemdump">3.13. memory dump</a></li>
          <li><a href="#pyview">3.14. view info</a></li>
          <li><a href="#pychbits">3.15. change bits</a></li>
          <li><a href="#pyexamples">3.16. real case examples</a></li>
        </ul>
      </li>
      <li>
        <a href="#libmwemu">4. LIBMWEMU from Rust apps</a>
        <ul>
            <li><a href="#libproject">4.1. Start a project</a></li>
            <li><a href="#libcompile">4.2. build project</a></li>
            <li><a href="#libcreate">4.3. Create the emulation object</a></li>
            <li><a href="#libconfigure">4.4. Configure the Emulator</a></li>
            <li><a href="#libmaps">4.5. Configuring Maps Folder</a></li>
            <li><a href="#libload">4.6. Loading ELF, PE, or shellcodes</a></li>
            <li><a href="#libbuffers">4.7. Creating Buffers</a></li>
            <li><a href="#libregisters">4.8. Registers</a></li>
            <li><a href="#libmemory">4.9. Memory operations</a></li>
            <li><a href="#libstart">4.10. Start Emulation</a></li>
            <li><a href="#libstack">4.11. Stack operations</a></li>
            <li><a href="#libbp">4.12. Breakpoints</a></li>
            <li><a href="#libmemdump">4.13. Memory dump</a></li>
            <li><a href="#libview">4.14. View info</a></li>
            <li><a href="#libchbits">4.15. Switch architecture bits</a></li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="content">
    <section id="intro">
      <h1>Intro</h1>
      <p>Welcome to official MWEMU documentation, you can do scrolling down or using the direct links that are on the
        left.</p>
      <p>Github repo: <a target="_blank"
          href="https://github.com/sha0coder/mwemu">https://github.com/sha0coder/mwemu</a></p>
      <p><img src="pics/mwemu_logo.png" width="60%"></p>
    </section>

    <section id="whatis">
      <h2>What is MWEMU?</h2>
      <p>MWEMU is a hardware emulator and Windows process simulator written in pure Rust from scratch, It was created by
        @sha0coder and It's open source. The contributors of this software have improved the quality of the project a
        lot, <a href="#contrib">click here to know them.</a>
      <p>
      <p>The implemented hardware is x86/x64, unlike other emulators also implemt some parts of the OS (mainly windows)
        because asm code soon or later is going to do system calls (WinAPI, linux syscalls, etc).</p>
      <p>It resulted extremely useful for malware deobfuscation, but this don't replace reversing, I't needed a previous
        reversing to prepare well the emulation initial state, and emulate only small group of functions, like
        decryption, keygen etc. In some specific cases mwemu can do full-emulation, wihth simple packers, encoded
        shellcodes, etc.</p>
      <p>The emulation and simulation is implemented from scratch, but the awesome Rust library iced-x86 is used to the
        translation from a bunch of bytes to instruction objects. I implemented more than 300 x86 instructions, flags,
        exceptions, some loaders PE32/PE64/ELF64/shellcode32/shellcode64 and many other stuff.</p>
      <p>MWEMU is blazing fast and also is memory-safe thanks to the Rust magic compiler.</p>
    </section>

    <section id="ways">
      <h2>The 3 ways of using MWEMU</h2>
      <p>1. The first way is commandline, see <a href="#commandline">commandline</a> for more details, this is for
        trying full-emulation.</p>
      <p>2. Second way is creating python scripts with pymwemu module, can be installed with pip or git.</p>
      <p>pypi: <a target="_blank" href="https://pypi.org/project/pymwemu/">https://pypi.org/project/pymwemu/</a></p>
      <p>If you need features or bug-fixes implemented recently use the git, will need to compile the full project and
        then the python bindings with maturin, more details in this section <a target="_blank" href="#pyinstall">pymwemu
          instalation</a></p>
      <p>3. Third way is using the rust crate published in crates.io <a target="_blank"
          href="https://crates.io/crates/libmwemu">https://crates.io/crates/libmwemu</a> from a rust application.</p>
    </section>

    <section id="archs">
      <h2>Architectures</h2>
      <p>You can run MWEMU from Windows, Linux and Mac (x86 and also m1)</p>
      <p>But only can be emulated x86 code (32bits and 64bits) mainly for Windows, there is linux shellcode support even
        syscalls are implemented but regarding ELF only 64bits, only static compiled and quite basic support for now,
        but no problem with shellcodes.</p>
      <p>libc can be emulated well despite it is plenty of ymm instructions, but the linker cannot be emulated totally
        so far, my plan is fully emulating the linker, in this case I don't need to implement the hole linking process
        (.got and .plt creation etc)</p>
    </section>

    <section id="internals">
      <h2>A bit of internals</h2>
      <p>For now, just a basic overview of the internals.</p>
      <p><img src="pics/arch.png" width="120%"></p>
      <p>In the past I named the project SCEMU, and was stored in 3 separated repos for mwemu (the commandline) pymwemu
        (pyhon module) and (libmwemu) the engine where all is implemented and also it's the Rust Crate module on
        crates.io.</p>
      <p>Then it was renamed to MWEMU, because SCEMU is more specific to shellcode and because it's an italian bad word.
      </p>
      <p>So, now it's one repo with a crates/ folder with the 3 crates.</p>
      <p>The tests are implemented on crates/libmwemu/src/tests/ and are described lately.</p>
      <p>Most of files were splitted in small files.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
~/s/mwemu ❯❯❯ ls crates/libmwemu/src/
banzai.rs       emu/               kuser_shared.rs
breakpoint.rs   emu_context.rs     lib.rs   
colors.rs       engine/            macros.rs
config.rs       err.rs             maps/    
console.rs      exception.rs       ntapi/   
constants.rs    exception_type.rs  pe/      
context/        flags.rs           peb/     
crit_state.rs   fpu/               regs64.rs    
definitions.rs  fpu.rs             script.rs
eflags.rs       global_locks.rs    serialization/
elf/            hooks.rs           structures/
syscall/        tests/             thread_context.rs
threading.rs    tools/             tracing.rs
utils.rs w      inapi/
              </code></pre>
      </figure>
      </p>
      <p>emu/ contains emu methods and sub-bojects that are involved in the emulation itself.</p>
      <p>In engine/ there are the implementation of all the instructions.</p>
      <p>winapi/ contains the WinAPI implemntations divided in winapi32/ and winapi64/</p>
      <p>there are other thigngs like contants.rs structures/ etc.</p>
    </section>

    <section id="test">
      <h2>Test System</h2>
      <p>For triggering locally use <code>make tests</code> this downloads some binaries and launch the test system
        <code>cargo test</code>
      </p>
      <p>Don't use --release, always is more convinient do the tests without aplying the optimizations, that could
        ignore some type of errors. Actually the github CI is configured to do cargo test and also cargo test --release
        to check both modes.</p>
      <p>Every git push or pull-request will trigger the CI in gibhut to perform all the tests in Linux, Windows and
        Mac. In in the case of PR is mandatory, in the case of a git push is only informative.</p>
      <p>PR also triggers a coverage analysis of the tests, which is currently only 32%</p>
      <p><img src="pics/tests.png" width="120%"></p>
    </section>

    <section id="contrib">
      <h2>Project Contributtors</h2>
      <p><a target="_blank" href="https://github.com/brandonros">Brandon Ros</a></p>
      <p><a target="_blank" href="https://github.com/acheron2302">Archeron2302</a></p>
      <p><a target="_blank" href="https://github.com/ElCapor">ElCapor</a></p>
      <p>There are also other people that suggested intereting ideas and optimizations.</p>
      <p>Regarding wit00 it's a github glitch for git pushing having a bad configuration in git config. (the bug was
        reported to github)</p>
      <p>I'm <a target="_blank" href="https://github.com/sha0coder">@sha0coder</a> and I created this software to
        empower my reversing engineering works, and I'm sharing this because I think it's useful for some cases.</p>
      <p>Some graphs:<a target="_blank"
          href="https://github.com/sha0coder/mwemu/graphs/contributors">https://github.com/sha0coder/mwemu/graphs/contributors</a>
    </section>

    <section id="Videos">
      <h2>Videos and pics</h2>
      <p><a target="_blank" href="https://www.youtube.com/watch?v=-TFL-_-nIqA">radare2 integration on mwemu -
          r2con2025</a></p>
      <p><a target="_blank" href="https://www.youtube.com/@JesusOlmos-wm8ch/videos">my youtube channel, there are some
          demos</a></p>
      <p><a target="_blank" href="https://x.com/noconname/status/1783878216458842312">zloader emulation -
          NcNLabs2022</a></p>
      <p><a target="_blank" href="https://www.youtube.com/watch?v=kfNWylFc6oY">Fixing FPU emulation</a></p>
    </section>

    <section id="license">
      <h2>License</h2>
      <p>Actually there are several licenses, the source code is GPLv3, but the crates.io rust module and pypi python
        module are MIT for having less restrictions in distributing software using libmwemu or pymwemu.</p>
      <p><a target="_blank"
          href="https://github.com/sha0coder/mwemu/blob/main/LICENSE">https://github.com/sha0coder/mwemu/blob/main/LICENSE</a>
      </p>
      <p>Don't hesitate in contact me for creating technologies based of this software.</p>
      <p>email: sha0 at badchecksum dot net</p>
    </section>

    <section id="cmdline">
      <h1>MWEMU commandline tool</h1>
      <p>The commandline is a quick way of using mwemu, and there are many features like register/memory/call/string
        tracing or capturing emulation moments.</p>
      <p>If the packer is simple probably can be full-emulated using the commandline tool, but if you need more control
        use pymwemu and for total control libmwemu.</p>
      <p>In rust you can compile and exec together with cargo run, use --release mode for faster execution, example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f file -vv -c 100
              </code></pre>
      </figure>
      </p>
      <p>This is equivalent of doing:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo build --release
❯❯❯ target/release/mwemu -6 -f file -vv -c 100
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="cmdline_install">
      <h2>MWEMU Installation</h2>
      <p>1. First you need to install Rust and Cargo, and the best way is using rustup.</p>
      <p><a target="_blank" href="https://rustup.rs/">https://rustup.rs/</a></p>
      <p>For instance in linux or mac:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
              </code></pre>
      </figure>
      </p>
      <p>In the default setup binaries are in ~/.cargo/bin/ but you need to add this to the path, ideally on last
        section of the path.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ export PATH="$PATH:/home/username/.cargo/bin/"
              </code></pre>
      </figure>
      </p>
      <p>The installer says how to put in the bashrc or other shells rc.</p>


      <p>2. Then there are 2 options to install this</p>
      <ul>
        <li>
          <p>Install from crates.io (is more convininent second option)</p>
          <p>
          <figure class="shell-block">
            <figcaption>Shell</figcaption>
            <pre><code>
❯❯❯ cargo install mwemu 
         </code></pre>
          </figure>
          </p>
        </li>
        <li>
          <p>The recommended way is cloning the github repo and compile from it, with Cargo it's simple.</p>
          <p>
          <figure class="shell-block">
            <figcaption>Shell</figcaption>
            <pre><code>
                git clone https://github.com/sha0coder/mwemu.git
                cargo build --release
                make tests
              </code></pre>
          </figure>
          </p>
        </li>
      </ul>
    </section>

    <section id="help">
      <h2>--help</h2>
      <p>Use help option for viewing the commandline options, note that the before the "--" there are cargo flags and
        after the "--" are the parameters of the program, in this case mwemu commandline.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
~/s/mwemu ❯❯❯ cargo run --release -- --help                                                                                                        Finished `release` profile [optimized] target(s) in 0.06s
Running `target/release/mwemu --help`
MWEMU emulator for malware 0.7.12
@sha0coder

USAGE:
    mwemu [FLAGS] [OPTIONS]

FLAGS:
    -6, --64bits             enable 64bits architecture emulation
        --banzai             skip unimplemented instructions, and keep up emulating what can be emulated
        --call               enable call tracer
        --entropy            display changes in the entropy
        --flags              trace the flags hex value in every instruction.
    -F, --fpu                trace the fpu states.
    -h, --handle             handle Ctrl+C to spawn console
        --help               Prints help information
    -l, --loops              show loop interations, it is slow.
        --multithread        enable multithread emulation
    -n, --nocolors           print without colors for redirecting to a file &gt;out
    -p, --stack_trace        trace stack on push/pop
    -t, --test               test mode
    -m, --trace_memory       trace all the memory accesses read and write.
    -r, --trace_registers    print the register values in every step.
        --version            Prints version information
    -v, --verbose            -vv for view the assembly, -v only messages, without verbose only see the api calls and
                             goes faster

OPTIONS:
    -A, --args <ARGS>                             provide arguments to the EXE like: --args '"aa" "bb"'
        --cmd <COMMAND>                           launch a console command
    -b, --base &lt;ADDRESS&gt;                          set base address for code
    -c, --console <NUMBER>                        select in which moment will spawn the console to inspect.
    -C, --console_addr &lt;ADDRESS&gt;                  spawn console on first eip = address
    -d, --dump <FILE>                             load from dump.
    -a, --entry &lt;ADDRESS&gt;                         entry point of the shellcode, by default starts from the beginning.
    -e, --exit <POSITION>                         exit position of the shellcode
    -f, --filename <FILE>                         set the shellcode binary file.
    -i, --inspect <DIRECTION>                     monitor memory like: -i 'dword ptr [ebp + 0x24]
    -L, --log &lt;LOG_FILENAME&gt;                      log output to file
    -M, --maps <PATH>                             select the memory maps folder
        --mxcsr <MXCSR>                           set mxcsr register
        --r10 <R10>                               set r10 register
        --r11 <R11>                               set r11 register
        --r12 <R12>                               set r12 register
        --r13 <R13>                               set r13 register
        --r14 <R14>                               set r14 register
        --r15 <R15>                               set r15 register
        --r8 <R8>                                 set r8 register
        --r9 <R9>                                 set r9 register
        --rax <RAX>                               set rax register
        --rbp <RBP>                               set rbp register
        --rbx <RBX>                               set rbx register
        --rcx <RCX>                               set rcx register
        --rdi <RDI>                               set rdi register
        --rdx <RDX>                               set rdx register
        --rflags <RFLAGS>                         set rflags register
        --rip <RIP>                               set rip register
        --rsi <RSI>                               set rsi register
        --rsp <RSP>                               set rsp register
    -x, --script &lt;SCRIPT&gt;                         launch an emulation script, see scripts_examples folder
        --stack_address &lt;ADDRESS&gt;                 set stack address
    -s, --string &lt;ADDRESS&gt;                        monitor string on a specific address
    -T, --trace_filename <TRACE_FILENAME>         output trace to specified file
    -R, --trace_register <REGISTER1,REGISTER2>    trace a specific register in every step, value and content
    -S, --trace_start <TRACE_START>               start trace at specified position
    -V, --verbose_at <NUMBER>
            start displaying assembly at specific position (is like -vv enabled in specific moment)
              </code></pre>
      </figure>
      </p>
      <p></p>
    </section>

    <section id="fullemu">
      <h2>Full Emulation</h2>
      <p>Main options are:</p>
      <ul>
        <li>
          <p>-6 for 64bits mode (otherwise would be 32bits)</p>
        </li>
        <li>
          <p>-f for selecting file path.</p>
        </li>
        <li>
          <p>-vv for vieweing the emulated assembler. (emulation is faster with no verbosity, in this case only shows
            the api calls)</p>
        </li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv  
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/fullemu.png" width="120%"></p>
    </section>

    <section id="moment">
      <h2>Capturing a moment</h2>
      <p>MWEMU displays always the number of emulated instructions, and this is a unique identificator of a moment.</p>
      <p>The moment 1 is the first assembly instruction, if you add the flag -c 1 the emulator will stop before
        emulating instruction 1</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
~/s/mwemu ❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1
    Finished `release` profile [optimized] target(s) in 0.07s
     Running `target/release/mwemu -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1`
static elf64 detected.
Entry point pointing to .text 0x401000
-------
1 0x401000: inc   al
--- console ---
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>The instruction 1 will not be colored, this means that that instruction is going to be emulated in next step.
      </p>
      <p>This spawns the console in that emulator state, and you can press enters to emulate steps or "h" command for
        viewing options.</p>
      <p>If verbose mode is not set, only WinAPI, syscalls etc will be displayed, but there will be also a number that
        represent the emulated instructions until that state.</p>
      <p>There is the option of stopping the emulator at specific address with uppercase "-C addr" but note that the
        address can be triggered multiple times and is not an unique identificator like the -c moment</p>
    </section>

    <section id="verbosity">
      <h2>Verbosity</h2>
      <p>There are 4 verbosity levels:</p>
      <ul>
        <li>
          <p>0: Don't use any -v for minimum verbosity, only WinAPI calls and syscalls will be printed.</p>
        </li>
        <li>
          <p>1: Use -v for viewing also some messages like, polymorfic code detected etc.</p>
        </li>
        <li>
          <p>2: Use -vv for viewing also the assembly code, mwemu will print every assembly instruction, this makes
            slower the emulation.2: Use -vv for viewing also the assembly code, mwemu will print every assembly
            instruction, this makes slower the emulation.</p>
        </li>
        <li>
          <p>3: Use -vvv for also viewing every "rep" interaction, in instruction with rep prefix like "rep movzx" will
            print one line for every step of the rep loop.</p>
        </li>
      </ul>
      <p>Use -V or --verbose_at for enabling verbose mode at specific point.</p>
      <p>The verbose mode is automatically enabled 100 instructions previous to the configured -c moment to stop.</p>
    </section>

    <section id="log">
      <h2>Logging</h2>
      <p>It's possible to redirect the output to a file, ie:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1 &gt; /tmp/log
              </code></pre>
      </figure>
      </p>
      <p>But note that colors are terminal escape bytes and will be logged making parsing more difficult, if you do cat
        /tmp/log you will see the colors but if you use an editor you will see those bytes</p>
      <p>It is more convinient using --log option for a clean logs.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -c 1 --log /tmp/log
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="initreg">
      <h2>Initialize registers</h2>
      <p>There are some cases like emulating dlls or chunk of code that needs some initial values in the registers.</p>
      <p>The commandline tool allows to set registers using those options:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
        --mxcsr &lt;MXCSR&gt;                           set mxcsr register
        --r10 &lt;R10&gt;                               set r10 register
        --r11 &lt;R11&gt;                               set r11 register
        --r12 &lt;R12&gt;                               set r12 register
        --r13 &lt;R13&gt;                               set r13 register
        --r14 &lt;R14&gt;                               set r14 register
        --r15 &lt;R15&gt;                               set r15 register
        --r8 &lt;R8&gt;                                 set r8 register
        --r9 &lt;R9&gt;                                 set r9 register
        --rax &lt;RAX&gt;                               set rax register
        --rbp &lt;RBP&gt;                               set rbp register
        --rbx &lt;RBX&gt;                               set rbx register
        --rcx &lt;RCX&gt;                               set rcx register
        --rdi &lt;RDI&gt;                               set rdi register
        --rdx &lt;RDX&gt;                               set rdx register
        --rflags &lt;RFLAGS&gt;                         set rflags register
        --rip &lt;RIP&gt;                               set rip register
        --rsi &lt;RSI&gt;                               set rsi register
        --rsp &lt;RSP&gt;                               set rsp register
              </code></pre>
      </figure>
      </p>
      <p>But note that colors are terminal escape bytes and will be logged making parsing more difficult, if you do cat
        /tmp/log you will see the colors but if you use an editor you will see those bytes</p>
      <p>It is more convinient using --log option for a clean logs.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -c 1 --rax 0x123 --rbx 0x1337
Finished `release` profile [optimized] target(s) in 0.08s
Running `target/release/mwemu -6 -f test/elf64lin_cpu_arithmetics1.bin -c 1 --rax 0x123 --rbx 0x1337`
static elf64 detected.
Entry point pointing to .text 0x401000
--- console ---
=&gt;r rax
rax: 0x123 291
=&gt;r rbx
rbx: 0x1337 4919
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="regtrace">
      <h2>Trace Registers</h2>
      <p>Use option -R &lt;registers to trace&gt; to trace some registers</p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/elf64lin_cpu_arithmetics1.bin -vv -R rax,rsp
...
57 0x4010a2: rcr   al,1
58 rax: 0x82f61001 2197164033
58 rsp: 0x7fffffffe270
58 0x4010a4: rcr   ax,1
59 rax: 0x82f60800 2197161984
59 rsp: 0x7fffffffe270
59 0x4010a7: rcr   eax,1
60 rax: 0xc17b0400 3246064640
60 rsp: 0x7fffffffe270
60 0x4010a9: rcr   rax,1
61 rax: 0x60bd8200 1623032320
61 rsp: 0x7fffffffe270
61 0x4010ac: rcr   al,cl
62 rax: 0x60bd8200 1623032320
62 rsp: 0x7fffffffe270
62 0x4010ae: rcr   ax,cl
63 rax: 0x60bd8200 1623032320
63 rsp: 0x7fffffffe270
63 0x4010b1: rcr   eax,cl
64 rax: 0x60bd8200 1623032320
64 rsp: 0x7fffffffe270
64 0x4010b3: rcr   rax,cl
65 rax: 0x60bd8200 1623032320
65 rsp: 0x7fffffffe270
65 0x4010b6: mov   eax,90909090h ; 0x90909090
66 rax: 0x90909090 2425393296
66 rsp: 0x7fffffffe270
66 0x4010bb: mov   edx,90909090h ; 0x90909090
67 rax: 0x90909090 2425393296
67 rsp: 0x7fffffffe270
67 0x4010c0: mov   ecx,0 ; 0x0
68 rax: 0x90909090 2425393296
68 rsp: 0x7fffffffe270
68 0x4010c5: shrd  eax,edx,cl
69 rax: 0x90909090 2425393296
69 rsp: 0x7fffffffe270
69 0x4010c8: ret ; ret-addr: 0x0 ret-value: 0x90909090
              </code></pre>
      </figure>
      </p>
      <p>You can trace one or multiple registers at same time with -R option but with no spaces between registers.</p>
    </section>

    <section id="memtrace">
      <h2>Trace Memory</h2>
      <p>There are 2 ways of tracing memory:</p>
      <ul>
        <li>
          <p>-m for tracing all the memory read and writes. (optionally -S moment enable the tracer from specific
            moment)</p>
        </li>
        <li>
          <p>-i 'dword ptr [eax + 0x8]' inspect mode allows many expressions but not all the combinations.</p>
        </li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/sc32win_donut.bin -vv -m -c 494253 -S 490000
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/memtrace.png" width="80%"></p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/sc32win_donut.bin -vv -m -i 'qword ptr [rsp + 0x8]'
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/inspect.png" width="80%"></p>
    </section>

    <section id="strtrace">
      <h2>Trace String</h2>
      <p>having the address of the string to trace, use -s &lt;addr&gt; to trace it</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -vv  -s 0x329ec8
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/strtrace.png" width="80%"></p>
      <p>Doing full verbose of millions of instructions is slower than non verbose mode, so let's enable the verbose
        mode only when it's needed.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -s 0x329ec8 -V 191
              </code></pre>
      </figure>
      </p>
      <p>Other option is using tracers with no verbose mode.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/sc64lin_strgen.bin -s 0x329ec8
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/strtrace2.png" width="80%"></p>
    </section>

    <section id="calltrace">
      <h2>Trace Function Calls</h2>
      <p>Following the call paths can be useful when combining emulation with static analysis to see where we are coming
        from.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/exe64win_enigma.bin --call
              </code></pre>
      </figure>
      </p>
      <p><img src="pics/calltrace.png" width="80%"></p>
      <p>In this case, it is more convinient not to use verbose mode.</p>
    </section>

    <section id="console">
      <h2>Interactive Console</h2>
      <p>With the option -c &lt;num&gt; mwemu stops the emulation when will reached that num of emulated instructions,
        then spawn a console.</p>
      <p>For instance, we don't want to emulate 102063765 instructions in verbose mode, It's faster not using verbose
        mode. The -c option will enable verbose mode and tracers 100 instructions before reaching that number, so when
        console is spawned we have some previous context.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo run --release -- -6 -f test/exe64win_enigma.bin -c 102063765
dll_path: maps/maps64//ntdll.dll dll: ntdll.dll
PE64 header detected.
loading memory maps
dll_path: maps/maps64//kernel32.dll dll: kernel32.dll
dll_path: maps/maps64//kernelbase.dll dll: kernelbase.dll
dll_path: maps/maps64//iphlpapi.dll dll: iphlpapi.dll
dll_path: maps/maps64//ws2_32.dll dll: ws2_32.dll
dll_path: maps/maps64//advapi32.dll dll: advapi32.dll
dll_path: maps/maps64//comctl32.dll dll: comctl32.dll
dll_path: maps/maps64//winhttp.dll dll: winhttp.dll
dll_path: maps/maps64//wininet.dll dll: wininet.dll
dll_path: maps/maps64//dnsapi.dll dll: dnsapi.dll
dll_path: maps/maps64//shell32.dll dll: shell32.dll
dll_path: maps/maps64//shlwapi.dll dll: shlwapi.dll
dll_path: maps/maps64//kernel32.dll dll: kernel32.dll
dll_path: maps/maps64//user32.dll dll: user32.dll
dll_path: maps/maps64//advapi32.dll dll: advapi32.dll
dll_path: maps/maps64//oleaut32.dll dll: oleaut32.dll
dll_path: maps/maps64//gdi32.dll dll: gdi32.dll
dll_path: maps/maps64//shell32.dll dll: shell32.dll
dll_path: maps/maps64//version.dll dll: version.dll
dll_path: maps/maps64//ole32.dll dll: ole32.dll
IAT Bound.
Delay load binding started ...
delay load bound!
entry point at 0x14072ce04
base: 0x140000000
102063740 0x14072d2ac: jne   000000014072D2A4h taken
102063741 0x14072d2a4: xor   [rax],dl
mem_trace: pos = 102063741 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cb value = 0x59 name = 'exe64win_enigma593000'
mem_trace: pos = 102063741 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cb value = 0x54 name = 'exe64win_enigma593000'
102063742 0x14072d2a6: inc   rax
102063743 0x14072d2a9: dec   rcx
102063744 0x14072d2ac: jne   000000014072D2A4h taken
102063745 0x14072d2a4: xor   [rax],dl
mem_trace: pos = 102063745 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cc value = 0x44 name = 'exe64win_enigma593000'
mem_trace: pos = 102063745 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cc value = 0x49 name = 'exe64win_enigma593000'
102063746 0x14072d2a6: inc   rax
102063747 0x14072d2a9: dec   rcx
102063748 0x14072d2ac: jne   000000014072D2A4h taken
102063749 0x14072d2a4: xor   [rax],dl
mem_trace: pos = 102063749 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4cd value = 0x42 name = 'exe64win_enigma593000'
mem_trace: pos = 102063749 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4cd value = 0x4f name = 'exe64win_enigma593000'
102063750 0x14072d2a6: inc   rax
102063751 0x14072d2a9: dec   rcx
102063752 0x14072d2ac: jne   000000014072D2A4h taken
102063753 0x14072d2a4: xor   [rax],dl
mem_trace: pos = 102063753 rip = 14072d2a4 op = read bits = 8 address = 0x14072d4ce value = 0x43 name = 'exe64win_enigma593000'
mem_trace: pos = 102063753 rip = 14072d2a4 op = write bits = 8 address = 0x14072d4ce value = 0x4e name = 'exe64win_enigma593000'
102063754 0x14072d2a6: inc   rax
102063755 0x14072d2a9: dec   rcx
102063756 0x14072d2ac: jne   000000014072D2A4h not taken
102063757 0x14072d2b2: jmp   000000014072D2BBh
mem_trace: pos = 102063758 rip = 14072d2bb op = read bits = 32 address = 0x14000303c value = 0x80 name = 'exe64win_enigma3000'
102063758 0x14072d2bb: mov   edi,[rsi+3Ch] ; 0x80
mem_trace: pos = 102063759 rip = 14072d2be op = read bits = 32 address = 0x140003110 value = 0x571000 name = 'exe64win_enigma3000'
102063759 0x14072d2be: mov   edi,[rdi+rsi+90h] ; 0x571000
102063760 0x14072d2c5: add   rdi,rsi
102063761 0x14072d2c8: cmp   dword ptr [rdi+0Ch],0
mem_trace: pos = 102063761 rip = 14072d2c8 op = read bits = 32 address = 0x14057400c value = 0x5722ac name = 'exe64win_enigma3000'
cmp: 0x5722ac &gt; 0x0
102063762 0x14072d2cc: je    000000014072D370h not taken
mem_trace: pos = 102063763 rip = 14072d2d2 op = read bits = 32 address = 0x14057400c value = 0x5722ac name = 'exe64win_enigma3000'
102063763 0x14072d2d2: mov   ecx,[rdi+0Ch] ; 0x5722ac
102063764 0x14072d2d5: add   rcx,rsi
-------
102063765 0x14072d2d8: call  qword ptr [rbp+5960B4h]
--- console ---
=&gt;
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="helpcmd">
      <h2>Help Command</h2>
      <p>press h to see the available commands:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;h
--- help ---
q ...................... quit
cls .................... clear screen
h ...................... help
s ...................... stack
v ...................... vars
sv ..................... set verbose level 0, 1 or 2
r ...................... register show all
r reg .................. show reg
rc ..................... register change
f ...................... show all flags
fc ..................... clear all flags
fz ..................... toggle flag zero
fs ..................... toggle flag sign
c ...................... continue
b ...................... breakpoint list
ba ..................... breakpoint on address
bi ..................... breakpoint on instruction number
bmr .................... breakpoint on read memory
bmw .................... breakpoint on write memory
bmx .................... breakpoint on execute memory
bcmp ................... break on next cmp or test
bc ..................... clear breakpoint
n ...................... next instruction
eip .................... change eip
rip .................... change rip
push ................... push dword to the stack
pop .................... pop dword from stack
fpu .................... fpu view
md5 .................... check the md5 of a memory map
seh .................... view SEH
veh .................... view vectored execption pointer
m ...................... memory maps
ms ..................... memory filtered by keyword string
ma ..................... memory allocs
mc ..................... memory create map
mn ..................... memory name of an address
ml ..................... memory load file content to map
mr ..................... memory read, speficy ie: dword ptr [esi]
mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
mwb .................... memory write bytes, input spaced bytes
md ..................... memory dump
mrd .................... memory read dwords
mrq .................... memory read qwords
mds .................... memory dump string
mdw .................... memory dump wide string
mdd .................... memory dump to disk
mdda ................... memory dump all allocations to disk
mt ..................... memory test
r2 [addr] .............. spawn radare2 console if it's isntalled
ss ..................... search string
sb ..................... search bytes
sba .................... search bytes in all the maps
ssa .................... search string in all the maps
ll ..................... linked list walk
d ...................... dissasemble
dt ..................... dump structure
pos .................... print current position
enter .................. step into
tr ..................... trace reg
trc .................... trace regs clear
ldr .................... show ldr linked list
iat .................... find api name in all iat's
iatx ................... addr to api name
iatd ................... dump the iat of specific module
dump ................... dump current state to disk
---
=&gt;
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="regcmd">
      <h2>Register Commands</h2>
      <p>Use r for viewing all the registers, or r [reg] to see specific register.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;r rsp
    rsp: 0x329f40
=&gt;r
    rax: 0x0 0
    rbx: 0x0 0
    rcx: 0x0 0
    rdx: 0x2f 47
    rsi: 0x0 0
    rdi: 0x0 0
    rsp: 0x329f40
    rbp: 0x329ff8
    rip: 0x3c006e
    r8 : 0x0 0
    r9 : 0x0 0
    r10: 0x0 0
    r11: 0x0 0
    r12: 0x0 0
    r13: 0x0 0
    r14: 0x0 0
    r15: 0x0 0
              </code></pre>
      </figure>
      </p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;rc rax
command not found, type h
=&gt;rc
register name=&gt;rax
value=&gt;0x1337
=&gt;r rax
    rax: 0x1337 4919
=&gt;
                </code></pre>
      </figure>
      </p>
      <p>you can use 64bits and 32bits registers only, 16/8bits is not allowed for now ("r ax" or "r al")</p>
    </section>

    <section id="mapscmd">
      <h2>Maps Command</h2>
      <p>press m to list all the memory maps and addresses.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;m
--- maps ---
oleaut32.data       0x7ff001dc7000 - 0x7ff001dca000 (12288)
ldr                 0x7ff000000000 - 0x7ff0000000b4 (180)
ntdll.pe            0x7ff000003000 - 0x7ff000004000 (4096)
kernelbase.text     0x7ff0002b6000 - 0x7ff0003c8000 (1122304)
ws2_32.didat        0x7ff00060f000 - 0x7ff000610000 (4096)
advapi32.pe         0x7ff000623000 - 0x7ff000624000 (4096)
winhttp.text        0x7ff000960000 - 0x7ff000a0f000 (716800)
iphlpapi.text       0x7ff00057f000 - 0x7ff0005a8000 (167936)
version.rsrc        0x7ff001e0c000 - 0x7ff001e0d000 (4096)
dnsapi.rdata        0x7ff000d6d000 - 0x7ff000d8f000 (139264)
kernelbase.rsrc     0x7ff000555000 - 0x7ff000556000 (4096)
comctl32.dll.ldr    0x7fe00000a000 - 0x7fe00000a940 (2368)
shell32.rsrc        0x7ff0012d8000 - 0x7ff001b1d000 (8671232)
advapi32.reloc      0x7ff0006cb000 - 0x7ff0006cd000 (8192)
advapi32.rdata      0x7ff00068a000 - 0x7ff0006bf000 (217088)
wininet.rsrc        0x7ff000cbe000 - 0x7ff000cd7000 (102400)
wininet.didat       0x7ff000cbd000 - 0x7ff000cbe000 (4096)
dnsapi.didat        0x7ff000d99000 - 0x7ff000d9a000 (4096)
ole32.pdata         0x7ff001f38000 - 0x7ff001f47000 (61440)
exe64win_enigma3000 0x140003000 - 0x140593000 (5832704)
user32.rsrc         0x7ff001c30000 - 0x7ff001d12000 (925696)
comctl32.pdata      0x7ff0008f9000 - 0x7ff00090f000 (90112)
oleaut32.text       0x7ff001d14000 - 0x7ff001da1000 (577536)
kernelbase.data     0x7ff000540000 - 0x7ff000545000 (20480)
winhttp.pdata       0x7ff000a3c000 - 0x7ff000a46000 (40960)
ws2_32.rdata        0x7ff0005fd000 - 0x7ff00060a000 (53248)
...
              </code></pre>
      </figure>
      </p>
      <p>We can see map name, start address, end address and size in bytes.</p>
      <p>Other memory related commands:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
m ...................... memory maps
ms ..................... memory filtered by keyword string
ma ..................... memory allocs
mc ..................... memory create map
mn ..................... memory name of an address
ml ..................... memory load file content to map
mr ..................... memory read, speficy ie: dword ptr [esi]
mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
mwb .................... memory write bytes, input spaced bytes
md ..................... memory dump
mrd .................... memory read dwords
mrq .................... memory read qwords
mds .................... memory dump string
mdw .................... memory dump wide string
mdd .................... memory dump to disk
mdda ................... memory dump all allocations to disk
mt ..................... memory test
              </code></pre>
      </figure>
      <p></p>
    </section>

    <section id="mncmd">
      <h2>Get Map details from Address</h2>
      <p>if the code is using an address and you want more details, use command mn.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;mn
address=&gt;0x140000008
map: exe64win_enigma.pe 0x140000000-0x140001000 (4096)
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>Note that mwemu commands dont accept parameters direcly, first type the command + enter then the parameter will
        prompted.</p>
      <p>except for the r2 command that needs an address to spawn radare2, ie: r2 0x140000008</p>
    </section>

    <section id="searchcmd">
      <h2>Search Commands</h2>
      <p>There are four commands to search.</p>
      <ul>
        <li>
          <p>use command ss for search a string in a specific map.</p>
        </li>
        <li>
          <p>use command sb for search a sequence of spaced bytes in a specific map.</p>
        </li>
        <li>
          <p>use command ssa for search a string in all the maps.</p>
        </li>
        <li>
          <p>use command sba for search a sequence of spaced bytes in all the maps.</p>
        </li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;ssa  (search string in all the maps)
string=&gt;http://something.com/
found at 0x329ec8 'http://something.com/'
found at 0x329fc8 'http://something.com/'
map not found

=&gt;mds (display string on an address)
address=&gt;0x329ec8
0x329ec8: 'http://something.com/'
=&gt;mds
address=&gt;0x329fc8
0x329fc8: 'http://something.com/'
=&gt; 

=&gt;mn (which map is that address?)
address=&gt;0x329ec8
map: stack 0x22a000-0x32c000 (1056768)
=&gt;mn
address=&gt;0x329fc8
map: stack 0x22a000-0x32c000 (1056768)
=&gt;

=&gt;ss (search string on specific address)
map name=&gt;stack
string=&gt;http://something.com/
found 0x329ec8 'http://something.com/'
found 0x329fc8 'http://something.com/'

=&gt;sb (search spaced bytes on specific address, ie searching hexlified "http://")
map name=&gt;stack
spaced bytes=&gt;68 74 74 70 3a 2f 2f
found at 0x329ec8
found at 0x329fc8
=&gt;
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="bpcmd">
      <h2>Breakpoint Commands</h2>
      <p>There are four types of breakpoints, but only one breakpoint can be set for each type at once.</p>
      <ul>
        <li>
          <p>break on address, the next time this address is reached the emulation will stop there.</p>
        </li>
        <li>
          <p>break on instruction, when the emulator reach that number of instructions emulated in total, will stop
            there.</p>
        </li>
        <li>
          <p>break on memory read, next time this address is readed by any assembly instruction (not api or syscall) the
            emulator will break there.</p>
        </li>
        <li>
          <p>break on memory write, next write to this address (doesn't matter if is a 1-byte write or any amount) will
            stop the emulation.</p>
        </li>
        <li>
          <p>break on next cmp or test instruction, this will stop the emulator on next cmp or test instruction.</p>
        </li>
      </ul>
      <p>Use command "b" to see the state of the 4 types of breakpoints.There are four commands to search.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;b
break on address: []
break on instruction: []
break on memory read: []
break on memory write: []
              </code></pre>
      </figure>
      </p>
      <p>Use these commands to set the breakpoints:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
b ...................... breakpoint list
ba ..................... breakpoint on address
bi ..................... breakpoint on instruction number
bmr .................... breakpoint on read memory
bmw .................... breakpoint on write memory
bmx .................... breakpoint on execute memory
bcmp ................... break on next cmp or test instruction
bc ..................... clear breakpoint
              </code></pre>
      </figure>
      </p>
      <p>Some examples:</p>
      <p><img src="pics/bpcmp.png" width="80%"></p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
--- console ---
=&gt;bi
instruction number=&gt;100
=&gt;c
18 0x3c006a: jne   short 00000000003C004Ah taken
19 0x3c004a: mov   rax,[rbp-8] ; 0x329f10
20 0x3c004e: movzx edx,byte ptr [rax]
21 0x3c0051: mov   rax,[rbp-10h] ; 0x329e10
22 0x3c0055: mov   [rax],dl ; 0x68
23 0x3c0057: add   qword ptr [rbp-8],1
24 0x3c005c: add   qword ptr [rbp-10h],1
25 0x3c0061: mov   rax,[rbp-8] ; 0x329f11
...
96 0x3c0065: movzx eax,byte ptr [rax]
97 0x3c0068: test  al,al
98 0x3c006a: jne   short 00000000003C004Ah taken
99 0x3c004a: mov   rax,[rbp-8] ; 0x329f18
-------
100 0x3c004e: movzx edx,byte ptr [rax]   (this instruction is the next to be emulated, it was not emulated yet)
--- console ---
=&gt;
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="svcmd">
      <h2>Change Verbosity</h2>
      <p>If you type the "sv" command, mwemu will ask you for the new verbosity level number, these are the possible
        verbose levels:</p>
      <ul>
        <li>
          <p>0: It's like not using any -v for minimum verbosity, only WinAPI calls and syscalls will be printed.</p>
        </li>
        <li>
          <p>1: It's like using -v for viewing also some messages like, polymorfic code detected etc.</p>
        </li>
        <li>
          <p>2: It's like using -vv for viewing also the assembly code, mwemu will print every assembly instruction,
            this makes slower the emulation.2: Use -vv for viewing also the assembly code, mwemu will print every
            assembly instruction, this makes slower the emulation.</p>
        </li>
        <li>
          <p>3: It's like using -vvv for also viewing every "rep" interaction, in instruction with rep prefix like "rep
            movzx" will print one line for every step of the rep loop.</p>
        </li>
      </ul>
      <p>For instance, we want to emulate quiclky the first 200 insturctions, and then enable the verbosity, this could
        be dont with -V, but let's do it from the console with "sv" command:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
~/s/mwemu ❯❯❯ cargo run --release -- -6 -f test/sc64win_strgen.bin -c 200
...
200 0x3c004e: movzx edx,byte ptr [rax]    (instruction 200 is not emulated yet, it's the next instruction to be emulated)
--- console ---
=&gt;sv
verbose level=&gt;3
=&gt; [enter for emulating instruction 200]
=&gt; c  (continue emulating now with maximum verbosity) 
...
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="ldrcmd">
      <h2>View LDR</h2>
      <p>The LDR is a triple circular liked list that cointains all the linked modules (not only DLL, also EXE)</p>
      <p>MWEMU provides several commands to view and query the LDR.</p>
      <ul>
        <li>
          <p>"ldr" command is the way of viewing the LDR contents.</p>
        </li>
        <li>
          <p>"iat" comamnd allows to find an specified api name in all the IAT's of every linked module.</p>
        </li>
        <li>
          <p>"iatx" If we have an address and we want to know which API name is, this command does the address to name
            query.</p>
        </li>
        <li>
          <p>"iatd" command dump the full IAT of a specified module.</p>
        </li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
--- console ---
=&gt;ldr
0x7fe000000000 loader.exe flink:7fe000004000 blink:7fe00000f000 base:7ff001b7e000 pe_hdr:f8 5045
0x7fe000004000 ntdll.dll flink:7fe000005000 blink:7fe000000000 base:7ff000003000 pe_hdr:e8 5045
0x7fe000005000 kernel32.dll flink:7fe000006000 blink:7fe000004000 base:7ff0001f8000 pe_hdr:f0 5045
0x7fe000006000 kernelbase.dll flink:7fe000007000 blink:7fe000005000 base:7ff0002b5000 pe_hdr:f0 5045
0x7fe000007000 iphlpapi.dll flink:7fe000008000 blink:7fe000006000 base:7ff00057e000 pe_hdr:f8 5045
0x7fe000008000 ws2_32.dll flink:7fe000009000 blink:7fe000007000 base:7ff0005b8000 pe_hdr:f0 5045
0x7fe000009000 advapi32.dll flink:7fe00000a000 blink:7fe000008000 base:7ff000623000 pe_hdr:100 5045
0x7fe00000a000 comctl32.dll flink:7fe00000b000 blink:7fe000009000 base:7ff0006cd000 pe_hdr:f0 5045
0x7fe00000b000 winhttp.dll flink:7fe00000c000 blink:7fe00000a000 base:7ff00095f000 pe_hdr:f8 5045
0x7fe00000c000 wininet.dll flink:7fe00000d000 blink:7fe00000b000 base:7ff000a4f000 pe_hdr:f0 5045
0x7fe00000d000 dnsapi.dll flink:7fe00000e000 blink:7fe00000c000 base:7ff000cd9000 pe_hdr:f8 5045
0x7fe00000e000 shell32.dll flink:7fe00000f000 blink:7fe00000d000 base:7ff000da4000 pe_hdr:f0 5045
0x7fe00000f000 shlwapi.dll flink:7fe000000000 blink:7fe00000e000 base:7ff001b2c000 pe_hdr:f0 5045
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="dtcmd">
      <h2>View Structures</h2>
      <p>The windows debugger windbg has a unique feature that is dt command to see information about structures, is
        quite useful and uniq.</p>
      <p>MWEMU implements a similar dt command but for specific structures, that could be useful in some situations.</p>
      <p>Let's use dt to inspect PEB structure.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;dt
structure=&gt;peb
address=&gt;0x7ffdf000
PEB {
    reserved1: [
        0x0,
        0x0,
    ],
    being_debugged: 0x0,
    reserved2: 0x0,
    reserved3: [
        0xffffffff,
        0x400000,
    ],
    ldr: 0x77647880,
    process_parameters: 0x2c1118,
    reserved4: [
        0x0,
        0x2c0000,
        0x77647380,
    ],
    alt_thunk_list_ptr: 0x0,
    reserved5: 0x0,
    reserved6: 0x6,
    reserved7: 0x773cd568,
    reserved8: 0x0,
    alt_thunk_list_ptr_32: 0x0,
    reserved9: [
        0x0,
...
              </code></pre>
      </figure>
      </p>
      <p>Let's use dt to inspect PEB_LDR_DATA structure.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;dt
structure=&gt;PEB_LDR_DATA
address=&gt;0x77647880
PebLdrData {
    length: 0x30,
    initializated: 0x1,
    sshandle: 0x0,
    in_load_order_module_list: ListEntry {
        flink: 0x2c18b8,
        blink: 0x2cff48,
    },
    in_memory_order_module_list: ListEntry {
        flink: 0x2c18c0,
        blink: 0x2cff50,
    },
    in_initialization_order_module_list: ListEntry {
        flink: 0x2c1958,
        blink: 0x2d00d0,
    },
    entry_in_progress: ListEntry {
        flink: 0x0,
        blink: 0x0,
    },
}
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>Let's use dt to inspect LDR_DATA_TABLE_ENTRY structure, that represents one LDR entry in the linked list of a
        specific linked module.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
=&gt;dt
structure=&gt;LDR_DATA_TABLE_ENTRY
address=&gt;0x2c18c0
LdrDataTableEntry {
    reserved1: [
        0x2c1950,
        0x77647894,
    ],
    in_memory_order_module_links: ListEntry {
        flink: 0x0,
        blink: 0x0,
    },
    reserved2: [
        0x0,
        0x400000,
    ],
    dll_base: 0x4014e0,
    entry_point: 0x1d000,
    reserved3: 0x40003e,
    full_dll_name: 0x2c1716,
    reserved4: [
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
        0x0,
    ],
    reserved5: [
        0x17440012,
        0x4000002c,
        0xffff0000,
    ],
    checksum: 0x1d6cffff,
    reserved6: 0xa640002c,
    time_date_stamp: 0xcdf27764,
}
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>Example: a malware is hiding something in an exception.</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
3307726 0x4f9673: push  ebp
3307727 0x4f9674: push  edx
3307728 0x4f9675: push  eax
3307729 0x4f9676: push  ecx
3307730 0x4f9677: push  ecx
3307731 0x4f9678: push  4F96F4h
3307732 0x4f967d: push  dword ptr fs:[0]
Reading SEH 0x0
-------
3307733 0x4f9684: mov   eax,[51068Ch]
--- console ---
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>Let's inspect exception structures:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
--- console ---
=&gt;r esp
        esp: 0x22de98
=&gt;dt
structure=&gt;cppeh_record
address=&gt;0x22de98
CppEhRecord {
    old_esp: 0x0,
    exc_ptr: 0x4f96f4,
    next: 0xfffffffe,
    exception_handler: 0xfffffffe,
    scope_table: PScopeTableEntry {
        enclosing_level: 0x278,
        filter_func: 0x51068c,
        handler_func: 0x288,
    },
    try_level: 0x288,
}
=&gt;
              </code></pre>
      </figure>
      </p>
      <p>And here we have the error routine 0x4f96f4 and the filter 0x51068c.</p>
    </section>

    <section id="viewcmd">
      <h2>View Data</h2>
      <p>There are multiple commands to view data, but currently I'm using the "r2 addr" command which is better bot for
        code and data. Note that r2 command executes the radare2 and transfer the memory map of the selected address,
        and sync radare2 with mwemu, but this command needs to have installed radare2 in the path, for instance from the
        git. More details on <a href="#r2cmd">radare2</a> chapter. It worth to install radare2.</p>


      <p>Commands for displaying information:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
mr ..................... memory read, speficy ie: dword ptr [esi]
mw ..................... memory write, speficy ie: dword ptr [esi]  and then: 1af
mwb .................... memory write bytes, input spaced bytes
md ..................... memory dump
mrd .................... memory read dwords
mrq .................... memory read qwords
mds .................... memory dump string
mdw .................... memory dump wide string
mdd .................... memory dump to disk
mdda ................... memory dump all allocations to disk
mt ..................... memory test
              </code></pre>
      </figure>
      </p>
      <p>Example with md command:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
--- console ---
=&gt;md
address=&gt;0x329ec8
0x329ec8: 68 74 74 70 3a 2f 2f 73 6f 6d 65 74 68 69 6e 67     http://something
0x329ed8: 2e 63 6f 6d 2f 00 00 00 00 00 00 00 00 00 00 00     .com/...........
0x329ee8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
0x329ef8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
0x329f08: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
0x329f18: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
0x329f28: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
0x329f38: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
=&gt;
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="r2cmd">
      <h2>Radare2 Command</h2>
      <p>This command gives a lot of power to MWEMU because we can use radare2 from inside of a MWEMU emualtion moment.
      </p>

      <p>Note that this executes another program (also free software) named radare2 that has to be installed and
        accesible from the path.</p>
      <p><img src="pics/radare2.png" width=20%></p>
      <p>The instalation is simple I will explan it later.</p>
      <p>Spawning radare over a data address:</p>
      <p><img src="pics/r2_px.png" width=80%></p>
      <p>Using q to return form r2 prompt to mwemu prompt and spawn radare again with a code address:</p>
      <p><img src="pics/r2_code.png" width=80%></p>
      <p>Radare are recognizing functions and decompiling them with the multiple decompilers, even we can use decai for
        AI based decompiled in python etc.</p>
      <p>More info specific of radare commands check the r2book: <a href="https://book.rada.re/"
          target="_blank">https://book.rada.re/</a></p>
      <p>Regarding the radare2 installation:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
❯❯❯ git clone https://github.com/radareorg/radare2.git
❯❯❯ cd radare2
❯❯❯ sys/install.sh
              </code></pre>
      </figure>
      </p>
      <p>The install.sh script does all the installation, It will prompt sudo to copy binaries to folders that are on
        the path.</p>
      <p>If radare2 is in the path, It would be possible to trigger it from mwemu r2 command.</p>
    </section>

    <section id="pymwemu">
      <h1>MWEMU from python scripts</h1>
      <p>This is probably the most practical use-case of MWEMU, using the pymwemu python module.</p>
    </section>

    <section id="pyinstall">
      <h2>pymwemu Instalation</h2>
      <p>They easiest way to install this is using pip, the package is published at pypi <a
          href="https://pypi.org/project/pymwemu/" target="_blank">https://pypi.org/project/pymwemu/</a></p>
      <p>For using latest version use git, but it's more tricky to install, because you need rust, cargo and maturin.
      </p>
      <p>It's precompiled for linux 64bits, so in linux in theory you don't need to install rust first.</p>
      <p>In linux you just do:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
❯❯❯ pip3 install pymwemu --break-system-packages
              </code></pre>
      </figure>
      </p>
      <p>In mac, windows or if the pip requires it, install first rust.</p>
      <p>Install rust from rustup, make sure cargo is on the path, and do pip or pip3:</p>
      <p>
      <figure class="shell-block">
        <figcaption>mwemu console</figcaption>
        <pre><code>
❯❯❯ pip install --upgrade pip
❯❯❯ pip3 install --upgrade pip
❯❯❯ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
❯❯❯ pip install pymwemu
❯❯❯ pip3 install pymwemu
              </code></pre>
      </figure>
      </p>
      <p>In mac, if there is a problem with !tapi-tbd the solution is:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ sudo xcode-select --switch /Library/Developer/CommandLineTools
              </code></pre>
      </figure>
      </p>
      <p>If there is the error: Caused by: feature `edition2024` is required. then update your rust: rustup update</p>
      <p>To verify the installation we can import the module in python console.</p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ python3
Python 3.13.5 (main, Jun 25 2025, 18:55:22) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import pymwemu
Initialized logging
&gt;&gt;&gt; emu = pymwemu.init64()
&gt;&gt;&gt; emu.version()
            '0.10.5'

              </code></pre>
      </figure>
      </p>
    </section>

    <section id="pycompile">
      <h2>build pymwemu (only for developers)</h2>
      <p></p>
      <p>
      <figure class="shell-block">
        <figcaption>shell</figcaption>
        <pre><code>
sudo apt install python3.13-venv
python3 -m venv .venv
source .venv/bin/activate.fish
pip install -U pip maturin
maturin develop --release
python
import pymwemu
Initialized logging  # loaded ok
^D
MATURIN_PYPI_TOKEN="..." maturin publish
        </code></pre>
      </figure>
      <p>remember to update version both in Crates.toml and pyproject.toml</p>
    </section>

    <section id="pycreate">
      <h2>Create the emulation object</h2>
      <p>First of all, import the module and init the 32bits or the 64bits engine.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; import pymwemu
Initialized logging
&gt;&gt;&gt; emu = pymwemu.init32()
            or
&gt;&gt;&gt; emu = pymwemu.init64()
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="pyconfigure">
      <h2>Configure the Emulator</h2>
      <p>Then there are some initial configurations you can do.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.set_verbose(3)     # to show all the assembly, normally this is not needed. By default is 0 verbose.
&gt;&gt;&gt; emu.enable_console()   # by default is disabled.
&gt;&gt;&gt; emu.spawn_console_at_pos(6) # useful for debugging the script.
loading memory maps
&gt;&gt;&gt;
&gt;&gt;&gt;
              </code></pre>
      </figure>
      </p>
      <p>All the configurations available:</p>
      <ul>
          <li><p><code>set_verbose(n: int)</code> 0: only display apicalls, 1: also messages, 2: also assembly, 3: also unrolled reps.</p></li>
          <li><p><code>enable_console()</code> this spawns mwemu command console.</p></li>
          <li><p><code>disable_console()</code></p></li>
          <li><p><code>spawn_console_at_pos(n: int)</code> spawn the console when position n will be reached (n instructions emulated)</p></li>
          <li><p><code>spawn_console_at_addr(addr: int)</code> spawn the console when addr is reached.</p></li>
          <li><p><code>disable_colors()</code></p></li>
          <li><p><code>enable_colors()</code></p></li>
          <li><p><code>enable_trace_mem()</code></p></li>
          <li><p><code>disable_trace_mem()</code></p></li>
          <li><p><code>enable_trace_regs()</code></p></li>
          <li><p><code>disable_trace_regs()</code></p></li>
          <li><p><code>enable_trace_reg(regs_list: list(str))</code> provide list of strings with name of registers to be traced.</p></li>
          <li><p><code>disable_trace_reg()</code></p></li>
          <li><p><code>update_ldr_entry_base(libname: str, base: int)</code></p></li>
          <li><p><code>set_stack_base(addr: int)</code></p></li>
          <li><p><code>enable_count_loops()</code></p></li>
          <li><p><code>disable_count_loops()</code></p></li>
          <li><p><code>enable_trace_string(addr: int)</code></p></li>
          <li><p><code>disable_trace_string()</code></p></li>
          <li><p><code>enable_inspect_sequence(seq: str)</code></p></li>
          <li><p><code>disable_inspect_sequence()</code></p></li>
          <li><p><code>enable_endpoint_mode()</code></p></li>
          <li><p><code>disable_endpoint_mode()</code></p></li>
          <li><p><code>set_entry_point(addr: int)</code></p></li>
          <li><p><code>set_base_address(addr: int)</code></p></li>
          <li><p><code>enable_stack_trace()</code></p></li>
          <li><p><code>disable_stack_trace()</code></p></li>
          <li><p><code>enable_test_mode()</code></p></li>
          <li><p><code>disable_test_mode()</code></p></li>
          <li><p><code>enable_banzai_mode()</code></p></li>
          <li><p><code>disable_banzai_mode()</code></p></li>
          <li><p><code>banzai_add(apiname: str, nparams: int)</code> banzai keep emulating on a non implemented API.</p></li>
          <li><p><code>enable_ctrlc()</code></p></li>
          <li><p><code>disable_ctrlc()</code></p></li>
      </ul>
          
    </section>

    <section id="pymaps">
      <h2>Loading Maps</h2>
      <p>In most of cases you will need to load all the Windows OS simulation part, to have all the PEB+TEB+LDR
        linkedlist and WinAPI infra.</p>
      <p>For doing this you can use <code>emu.load_maps(folder:str)</code></p>
      <p>If you are going to emulate pure assembly, with no api calls, and no access to windows structures, you don't
        need to load the maps.</p>
      <p>So does if you are emulating linux elf64 or shellcodes (remember, elf64 is not well suported for now)</p>
      <p>Example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.load_maps('/home/sha0/src/mwemu/maps/maps64/')
loading memory maps
dll_path: /home/sha0/src/mwemu/maps/maps64//ntdll.dll dll: ntdll.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//kernel32.dll dll: kernel32.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//kernelbase.dll dll: kernelbase.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//iphlpapi.dll dll: iphlpapi.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//ws2_32.dll dll: ws2_32.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//advapi32.dll dll: advapi32.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//comctl32.dll dll: comctl32.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//winhttp.dll dll: winhttp.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//wininet.dll dll: wininet.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//dnsapi.dll dll: dnsapi.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//shell32.dll dll: shell32.dll
dll_path: /home/sha0/src/mwemu/maps/maps64//shlwapi.dll dll: shlwapi.dll
&gt;&gt;&gt;
              </code></pre>
      </figure>
      </p>
      <p>Note that this need to have the maps, so git clone the repo:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ git clone https://github.com/sha0coder/mwemu.git 
                </code></pre>
      </figure>
      </p>
    </section>

    <section id="pyload">
      <h2>loading ELF, PE, or shellcodes</h2>
      <p></p>
      <ul>
        <li>
          <p><code>emu.load_binary(filename:str)</code> load the sample to be emulated.</p>
        </li>
        <li>
          <p><code>emu.load_code_bytes(opcodes:bytes)</code> if you have the bytes already on python bytes() /
            bytearray()</p>
        </li>
      </ul>

      <p>Example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.load_binary('shellcodes32/shikata.bin')
&gt;&gt;&gt;
              </code></pre>
      </figure>
      </p>
      <p>It detects if it's ELF, PE and otherwise is a shellcode.</p>
      <p>In the case of PE or shellcode the win32 simulation is initialized automatically.</p>
      <p>In the case of ELF the linux64 simulation is initialized automatically.</p>
      <p>But if for any reason you don't use load_binary() and you need the windows simulator with peb/ldr/dlls loaded on the memory, you need to call init_win32 (even for 64bits, it will detect the arch)</p>
      <p>And if you dont use load_binary() but you need the linux simulator with libc etc loaded, use init_linux64. Note that linux implementation is very basic and only for static 64bits</p>
      <p>Note that calling init_win32() requires previously to have done load_maps to set the maps folder.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.init_win32()
            or
&gt;&gt;&gt; emu.init_linux64(is_dynamic)
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="pybuffers">
      <h2>Creating Buffers</h2>
      <p>You can load sections from disk to the emulator's virtual memory, and also can allocate buffers.</p>
      <ul>
            <li><p><code>alloc(name: str, size: int) -&gt; int</code> simplest way to alloc a buffer, it returns the address.</p></li>
            <li><p><code>alloc_at(name: str, addr: int, size: int)</code> the name is an unique id of the allocated map.</p></li>
            <li><p><code>load_map(name: str, filename: str, base_addr: int)</code> load extra payloads from disk, sections dumped etc.</p></li>
            <li><p><code>link_library(filepath: str) -&gt; int</code> link a custom dll in the LDR.</p></li>
            <li><p><code>free(name: str)</code> free an allocation.</p></li>
      </ul>

      <p>Examples:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; addr = emu.alloc("mybuffer", 1024)
&gt;&gt;&gt; emu.alloc_at("mybuffer", 0x1000, 1024)
&gt;&gt;&gt; emu.load_map("mybuffer", "something.dll", 0x1000)
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pyregisters">
      <h2>Registers</h2>
      <p>You can view the register values and modify it in any moment.</p>
      <p>For instance to prepare the context previous to the emulation, preparing an emulation state.</p>
      <ul>
            <li><p><code>get_reg(reg: str) -&gt; int</code> provide the name of the register to view it.</p></li>
            <li><p><code>set_reg(reg: str, value: int) -&gt; int</code> modify a register.</p></li>
            <li><p><code>get_xmm(reg: str) -&gt; u128</code> also can view xmm registers.</p></li>
            <li><p><code>set_xmm(reg: str, value: u128) -&gt; u128</code> and can modify xmm registers.</p></li>
            <li><p><code>set_rip(addr: int) -&gt; bool</code></p> for changing rip triggering all flow change logic ie winapi calls etc.</li>
            <li><p><code>set_eip(addr: int) -&gt; bool</code></p> for changing eip triggering all flow change logic ie winapi calls etc.</li>
      </ul>

      <p>Examples:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; rax = emu.get_reg('rax')
&gt;&gt;&gt; emu.set_reg('rax', rax+1)
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pymemory">
      <h2>Memory operations</h2>
      <p>It could be useful for pinpoint the emulation state before starting the emulation, but other option is checking the memory after the emulation or altering it during the emulation.</p>
      <p>Note that this read/write are inside the emulation virtual memory.</p>
      <ul>
          <p><h3>memory write</h3></p>
            <li><p><code>write_qword(addr: int, value: int) -&gt; bool</code></p></li>
            <li><p><code>write_dword(addr: int, value: int) -&gt; bool</code></p></li>
            <li><p><code>write_word(addr: int, value: u16) -&gt; bool</code></p></li>
            <li><p><code>write_byte(addr: int, value: u8) -&gt; bool</code></p></li>
            <li><p><code>write_bytes(to: int, from: bytes)</code></p></li>
            <li><p><code>write_string(to: int, from: str)</code></p></li>
            <li><p><code>write_wide_string(to: int, from: str)</code></p></li>
            <li><p><code>write_buffer(to: int, from: bytes)</code></p></li>
            <li><p><code>write_spaced_bytes(addr: int, spaced_hex_bytes: str) -&gt; bool</code></p></li>

          <p><h3>read operations</h3></p>
            <li><p><code>read_128bits_be(addr: int) -&gt; u128</code></p></li>
            <li><p><code>read_128bits_le(addr: int) -&gt; u128</code></p></li>
            <li><p><code>read_qword(addr: int) -&gt; int</code></p></li>
            <li><p><code>read_dword(addr: int) -&gt; int</code></p></li>
            <li><p><code>read_word(addr: int) -&gt; u16</code></p></li>
            <li><p><code>read_byte(addr: int) -&gt; u8</code></p></li>
            <li><p><code>read_buffer(from: int, sz: int) -&gt; Vec<u8</code></p></li>
            <li><p><code>read_bytes(addr: int, sz: int) -&gt; bytes</code></p></li>
            <li><p><code>read_string_of_bytes(addr: int, sz: int) -&gt; str</code></p></li>
            <li><p><code>read_string(addr: int) -&gt; str</code></p></li>
            <li><p><code>read_wide_string(addr: int) -&gt; str</code></p></li>

          <p><h3>libc style memory operations:</h3></p>
            <li><p><code>memset(addr: int, byte: int, amount: int)</code></p></li>
            <li><p><code>memcmp(to_addr: int, from_addr: int, amount: int)</code></p></li>
            <li><p><code>sizeof_wide(unicode_str_ptr: int) -&gt; int</code></p></li>

          <p><h3>search methods:</h3></p>
            <li><p><code>search_spaced_bytes_from(saddr: int, sbs: str) -&gt; int</code></p></li>
            <li><p><code>search_spaced_bytes_from_bw(saddr: int, sbs: str) -&gt; int</code></p></li>
            <li><p><code>search_spaced_bytes(sbs: str, map_name: str) -&gt; Vec<int</code></p></li>
            <li><p><code>search_spaced_bytes_in_all(sbs: str) -&gt; Vec<int</code></p></li>
            <li><p><code>search_string(kw: str, map_name: str) -&gt; list[int]</code> search a string in a specific map.</p></li>
            <li><p><code>search_string_in_all(kw: str)</code> search a string in all the memory maps, not very useful becaouse dont return the result, just print it. It will be improved.</p></li>
            <li><p><code>search_bytes(bkw: bytes, map_name: str) -&gt; list[int]</code> search bytes in a specific memory map, the result is a list of addresses.</p></li>
      </ul>

      <p>Examples of preparing context previous to start emulation:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; some_data_structure_needed = open('blob.bin','rw').read()
&gt;&gt;&gt; addr = emu.alloc("struct1", len(some_data_structure_needed))
&gt;&gt;&gt; emu.write_bytes(addr, some_data_structure_needed)
&gt;&gt;&gt; emu.set_reg('rdi', addr)
&gt;&gt;&gt; rax = emu.call32(0x40323, [addr, 0])
        </code></pre>
      </figure>
      </p>
      <p>Another example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Script</figcaption>
        <pre><code>
import pymwemu

emu = pymwemu.init64()
buffer_addr = emu.alloc("mybuffer", 1024)

# Write a string
emu.write_string(buffer_addr, "Hello MWEMU!")

# Read it back
text = emu.read_string(buffer_addr, 12)
print(f"Read: {text}")

# Write dword
emu.write_dword(buffer_addr + 0x100, 0x12345678)
value = emu.read_dword(buffer_addr + 0x100)
print(f"DWORD: {hex(value)}")

# Write raw bytes
data = b"\x90\x90\x90\xc3"  # nop nop nop ret
emu.write_buffer(buffer_addr + 0x200, data)
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="pystart">
      <h2>Start Emulation</h2>
      <p>Once everything is configured, you can start the emulation.</p>
      <ul>
            <li><p><code>run(end_addr) -&gt; int</code> provide the address to end the emulation or None to emulate as further as possible.</p></li>
            <li><p><code>run_to(position: int) -&gt; int</code> emulate a specific number of instructions.</p></li>
            <li><p><code>call32(address: int, params: list[int]) -&gt; int</code> call a funcion using microsoft 32bits calling convention.</p></li>
            <li><p><code>call64(address: int, params: list[int]) -&gt; int</code> call a functon using microsoft 64bits calling convention.</p></li>
            <li><p><code>linux_call64(address: int, params: list[int]) -&gt; int</code> call a function using linux 64bits calling convention.</p></li>
            <li><p><code>stop()</code> stop emulation, i never used this call.</p></li>
            <li><p><code>run_until_return() -&gt; int</code></p></li>
            <li><p><code>run_until_apicall() -&gt; (int, str)</code></p></li>
            <li><p><code>step() -&gt; bool</code> you can use a while step(): loop and control the situation step by step. This is slow.</p></li>
            <li><p><code>handle_winapi(addr: int)</code></p></li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>Python Script - basic_run.py</figcaption>
        <pre><code>
import pymwemu

emu = pymwemu.init64()
emu.load_binary('shellcode.bin')

rip = emu.run(None)

print("Emulation finished")
print(f"Final RAX: {hex(emu.get_rax())}")
print(f"Instructions executed: {emu.get_pos()}")
              </code></pre>
      </figure>
      </p>

      <h3>Calling Functions Directly</h3>
      <p>You can call functions at specific addresses with call32/call64:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Script - call_function.py</figcaption>
        <pre><code>
import pymwemu

# Example: call a decryption function
emu = pymwemu.init64()
emu.load_maps('/path/to/maps/maps64/')
emu.load_binary('malware.exe')

# Allocate buffer for output
output_buffer = emu.alloc("output", 1024)

# Call function at 0x401234 with arguments
# Function signature: decrypt(char* input, char* output, int size)
encrypted_str = 0x404000  # address of encrypted data
result = emu.call64(0x401234, [encrypted_str, output_buffer, 100])

# Read decrypted result
decrypted = emu.read_string(output_buffer, 100)
print(f"Decrypted: {decrypted}")
print(f"Return value: {hex(result)}")
              </code></pre>
      </figure>
      </p>

      <p>
      <figure class="shell-block">
        <figcaption>Python Script - call32_example.py</figcaption>
        <pre><code>
import pymwemu

# Example with 32-bit malware
emu = pymwemu.init32()
emu.load_binary('malware32.exe')

# Call a string decryption routine
# Function: char* decrypt_string(int index)
decrypt_func = 0x00401200

for i in range(10):
    # Call function with index
    result_addr = emu.call32(decrypt_func, [i])
    
    # Read decrypted string
    if result_addr != 0:
        decrypted = emu.read_string(result_addr, 256)
        print(f"String {i}: {decrypted}")
              </code></pre>
      </figure>
      </p>

      <h3>Step-by-Step Emulation</h3>
      <p>For debugging or detailed control, execute instruction by instruction:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Script - step_by_step.py</figcaption>
        <pre><code>
import pymwemu

emu = pymwemu.init64()
emu.set_verbose(2)  # show assembly
emu.load_binary('shellcode.bin')

# Execute 10 instructions one by one
for i in range(10):
    emu.step()
    rip = emu.get_rip()
    rax = emu.get_rax()
    print(f"Step {i+1}: RIP={hex(rip)} RAX={hex(rax)}")

print(f"Total instructions: {emu.get_pos()}")
              </code></pre>
      </figure>
      </p>


      <h3>Additional Useful Methods</h3>
      <p>Other helpful methods for emulation control:</p>
      <ul>
        <li>
          <p><code>emu.get_pos() -&gt; int</code> get current instruction position</p>
        </li>
        <li>
          <p><code>emu.set_verbose(level:int)</code> set verbosity (0=quiet, 1=API, 2=asm, 3=all)</p>
        </li>
        <li>
          <p><code>emu.spawn_console()</code> spawn interactive console</p>
        </li>
        <li>
          <p><code>emu.print_maps()</code> print the full list of maps.</p>
        </li>
        <li>
          <p><code>emu.print_maps_by_keyword(kw: str)</code> print the maps that match with that keyword.</p>
        </li>
        <li>
          <p><code>emu.search_bytes(pattern:bytes) -&gt; list</code> search for byte pattern in memory.</p>
        </li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; # Run and then spawn console for inspection
&gt;&gt;&gt; emu.run(1000)
&gt;&gt;&gt; emu.spawn_console()  # interactive debugging
&gt;&gt;&gt; 
&gt;&gt;&gt; 
&gt;&gt;&gt; # Search for strings
&gt;&gt;&gt; addresses = emu.search_bytes(b"http://")
&gt;&gt;&gt; for addr in addresses:
...     print(f"Found at: {hex(addr)}")
&gt;&gt;&gt;
              </code></pre>
      </figure>
      </p>

      <h3>Practical Example: String Decryption</h3>
      <p>A typical use case is decrypting malware strings:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Script - string_decrypt.py</figcaption>
        <pre><code>
#!/usr/bin/env python3
import pymwemu

# Initialize
emu = pymwemu.init32()  # 32-bit malware
emu.load_binary('malware32.exe')

# Find encrypted strings in .data section
encrypted_strings = [
    0x00401000,
    0x00401100,
    0x00401200,
]

# Decrypt function address (from IDA/Ghidra)
decrypt_func = 0x00402340

decrypted = []

for enc_addr in encrypted_strings:
    # Set parameters
    emu.set_eax(enc_addr)  # pointer to encrypted string
    emu.set_eip(decrypt_func)  # start at decrypt function
    
    # Run until return
    emu.run(10000)
    
    # Read decrypted result (assume in EAX)
    result_addr = emu.get_eax()
    decrypted_str = emu.read_string(result_addr, 256)
    
    print(f"Encrypted {hex(enc_addr)} -&gt; {decrypted_str}")
    decrypted.append(decrypted_str)

# Save results
with open('decrypted_strings.txt', 'w') as f:
    for s in decrypted:
        f.write(s + '\n')
              </code></pre>
      </figure>
      </p>
    </section>


    <section id="pystack">
      <h2>Stack operations</h2>
      <p>There are methods for altering the stack, note that you also could do emu.write_qword(emu.get_reg('rsp'), 123)</p>
      <p>But with this meethods you trigger all the stack logic, also incrementing rsp/esp.</p>
      <ul>
            <li><p><code>stack_push32(value: int) -&gt; bool</code></p></li>
            <li><p><code>stack_push64(value: int) -&gt; bool</code></p></li>
            <li><p><code>stack_pop32() -&gt; int</code></p></li>
            <li><p><code>stack_pop64() -&gt; int</code></p></li>
      </ul>

      <p>This example simulates a stack based calling convention, but note that you can also use call32() and call64() and linux_call64() methods.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.stack_push32(ret_addr)
&gt;&gt;&gt; emu.stack_push32(param1)
&gt;&gt;&gt; emu.stack_push32(param2)
&gt;&gt;&gt; emu.set_reg('rip', 0x40123)
&gt;&gt;&gt; emu.run(None)
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pybp">
      <h2>Breakpoints</h2>
      <p>mwemu's breakpoitns are simple, and most of times there are better ways to trigger the emulation to stop.</p>
      <p>You can bp an adderss (only one at time ...) or instruction, also memory read/write</p>
      <ul>
            <li><p><code>bp_show()</code></p></li>
            <li><p><code>bp_clear_all()</code></p></li>
            <li><p><code>bp_set_addr(addr: int)</code></p></li>
            <li><p><code>bp_get_addr() -&gt; Vec<int</code></p></li>
            <li><p><code>bp_set_inst(ins: int)</code></p></li>
            <li><p><code>bp_get_inst() -&gt; Vec<int</code></p></li>
            <li><p><code>bp_set_mem_read(addr: int)</code></p></li>
            <li><p><code>bp_get_mem_read() -&gt; Vec<int</code></p></li>
            <li><p><code>bp_set_mem_write(addr: int)</code></p></li>
            <li><p><code>bp_get_mem_write() -&gt; Vec<int</code></p></li>
      </ul>

      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.set_bp_addr(0x11223344)
&gt;&gt;&gt; emu.run(None)
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pymemdump">
      <h2>Memory dump</h2>
      <p>there are several ways do do a memory dump</p>
      <ul>
          <li><p><code>save_all_allocs(path: str)</code> only save to disk allocations done by the emulated code.</p></li>
          <li><p><code>save(addr: int, size: int, filename: str)</code> dump specific blob to disk.</p></li>
      </ul>

      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; emu.print_maps()
...
&gt;&gt;&gt; emu.save(0x40324234, 1024, "/tmp/blob.bin")
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pyview">
      <h2>View info</h2>
      <p>There are some less used methods to fetch different type of information.</p>
      <ul>
            <li><p><code>version() -&gt; str</code></p> get current pymwemu version.</li>
            <li><p><code>get_prev_mnemonic() -&gt; str</code> get last emulated mnemonic.</p></li>
            <li><p><code>reset_pos()</code> reset the emulated instruction count to zero.</p></li>
            <li><p><code>is_64bits() -&gt; bool</code> detect in which mode is the emulator.</p></li>
            <li><p><code>is_32bits() -&gt; bool</code> detect in which mode is the emulator.</p></li>
            <li><p><code>get_position() -&gt; int</code> get current pos, (amount of emulated instructions).</p></li>
            <li><p><code>disassemble(addr: int, amount: int) -&gt; str</code> dissassemble bytes.</p></li>
            <li><p><code>print_maps()</code> print all the maps (allocs, linked dlls, etc)</p></li>
            <li><p><code>print_maps_by_keyword(kw: str)</code> print the maps that contain a keyword.</p> </li>
            <li><p><code>get_addr_base(addr: int) -&gt; int</code> get the begining of a map.</p></li>
            <li><p><code>is_mapped(addr: int) -&gt; bool</code> check if an address is allocated.</p></li>
            <li><p><code>get_addr_name(addr: int) -&gt; str</code> get in which map name is the address.</p></li>
            <li><p><code>dump(addr: int)</code> print bytes.</p></li>
            <li><p><code>dump_n(addr: int, amount: int)</code> print n bytes.</p></li>
            <li><p><code>dump_qwords(addr: int, n: int)</code> print a list of qwords.</p></li>
            <li><p><code>dump_dwords(addr: int, n: int)</code> print a list of dwords.</p></li>
            <li><p><code>allocated_size() -&gt; int</code> show the total allocated memory.</p></li>
            <li><p><code>memory_overlaps(addr: int, sz: int) -&gt; bool</code> check if a memory block overlaps with existing map.</p></li>
            <li><p><code>show_allocs()</code> print all the allocations.</p></li>
            <li><p><code>mem_test() -&gt; bool</code> do a automatic memory test to look for map overlapps.</p></li>
            <li><p><code>api_addr_to_name(addr: int) -&gt; str</code> provide an address pointing to an API and will fetch the API name.</p></li>
            <li><p><code>api_name_to_addr(name: str) -&gt; int</code> get the address of an api name.</p></li>
      </ul>

      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; name = api_addr_to_name(0x11223344)
&gt;&gt;&gt; print( name )
        MessageBoxA
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pychbits">
      <h2>Change architecture bits.</h2>
      <p>There are methods for changing from 32bits to 64bits and vice versa.</p>
      <ul>
            <li><p><code>set_64bits()</code></p></li>
            <li><p><code>set_32bits()</code></p></li>
            <li><p><code>inspect_seq(s: str)</code></p></li>
      </ul>
      <p>But better don't change the architecture on the fly, re-instantiate the emulation object like:</p>

      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>Python Console</figcaption>
        <pre><code>
&gt;&gt;&gt; import pymwemu
&gt;&gt;&gt; emu = pymwemu.init32()
&gt;&gt;&gt; ... 
&gt;&gt;&gt; emu = pymwemu.init64()
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="pyexamples">
      <h2>Real case examples.</h2>
      <p>Find some examples here:</p>
      <p><a href="https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples/scripts">https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples/scripts</a></p>
      <p>And some jupyter nobebooks here:</p>
      <p><a href="https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples">https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples</a></p>
    </section>




    <!---------- LIBMWEMU --------------->

    <section id="libmwemu">
      <h2>MWEMU for Rust apps</h2>
      <p>Core and bindings are everything implemented in Rust, and all the logic is inside libmwemu, so a rust program can have even more control of the emulator than pymwemu.</p>
      <p>So having said that, from Rust you can use all the power of MWEMU, and access to most of the objects because are public most of them, so you can have a good control of the emulator.</p>
      <p><a href="https://docs.rs/libmwemu/0.23.5/libmwemu/"
          target="_blank">https://docs.rs/libmwemu/0.23.5/libmwemu/</a></p>
      <p><a href="https://crates.io/crates/libmwemu" target="_blank">https://crates.io/crates/libmwemu</a></p>
    </section>

    <section id="libproject">
      <h2>Start a project</h2>
      <p>First of all you need the rustc compiler and the cargo tool, best way of installing this is rustup.rs</p>
      <p>
        <figure class="shell-block">
          <figcaption>Shell</figcaption>
          <pre><code>
  ❯❯❯ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
                </code></pre>
        </figure>
        </p>
      <p>Then you have to create a rust project.</p>
        <p>
        <figure class="shell-block">
          <figcaption>Shell</figcaption>
          <pre><code>
  ❯❯❯ cargo init --bin myproject
  ❯❯❯ cd myproject
                </code></pre>
        </figure>
        </p>
      <p>This creates a folder with src/main.rs and also Cargo.toml</p>
      <p>Add de dependency to Cargo.toml manually or better automatically using cargo too.</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ cargo add libmwemu

❯❯❯ cat Cargo.toml
[package]
name = "myproject"
version = "0.1.0"
edition = "2024"

[dependencies]
libmwemu = "0.23.5"
              </code></pre>
      </figure>
      </p>
      <p>Then you can add code to src/main.rs</p>
    </section>

    <section id="libcompile">
      <h2>build project</h2>
      <p>If you need to run the project remember to use the release mode (adding --release)</p>
      <p>In release mode the emulator is blazing fast.</p>
      <p>
      <figure class="shell-block">
        <figcaption>shell</figcaption>
        <pre><code>
  ❯❯❯ cargo run --release
        </code></pre>
      </figure>
      </p>
      <p>The compilation will be slower the first time because have to download the libmwemu and compile it automaticall.</p>
      <p>What cargo run does internally is compiling like (cargo build --release) and then execute the binary.</p>
      <p>You can pass parameter to cargo and also to your code in this way:</p>
      <p><code>cargo run [cargo args] -- [you program args]</code> example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>shell</figcaption>
        <pre><code>
  ❯❯❯ cargo run --release -- samples/binary.exe
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="libcreate">
      <h2>Create the emulation object</h2>
      <p>First of all, use the emu32 or emu64 object depending what you need.</p>
      <p>If you will do memory allocations you al will need to use the Permission object.</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
use libmwemu::emu32;
use libmwemu::maps::mem64::Permission;
        </code></pre>
      </figure>
      </p>
      <p>Note that even in 32bits the Permission object implementation is implemented in mem64, actually internally all is 64bits</p>
      <p>Then create the emulation object for the chosen architecture.</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut emu = emu32();  // or also emu64()
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="libconfigure">
      <h2>Configure the Emulator</h2>
      <p>Then optionally you can use modificators to configure the emulator, even access directly to Config object</p>
      <p>All the configurations available:</p>
      <ul>
            <li><p><code>emu.set_verbose(n: u32)</code> change verbosity, 0: only show winapi calls, 1: also messages, 2: also every asm instructions, 3: also every rep iteration.</p></li>
            <li><p><code>emu.set_stack_address(addr: u64)</code></p></li>
            <li><p><code>emu.set_base_address(addr: u64)</code> set the base address of the code, the initial emulable blob, by default mwemu gets it from the PE/ELF structures.</p></li>

            <li><p><code>emu.disable_ctrlc()</code></p></li>
            <li><p><code>emu.disable_console()</code></p></li>
            <li><p><code>emu.disable_banzai()</code></p></li>
            <li><p><code>emu.disable_color()</code></p></li>
            <li><p><code>emu.disable_interrupt()</code></p></li>
            <li><p><code>emu.disable_exception()</code></p></li>
            <li><p><code>emu.disable_memory_read()</code></p></li>
            <li><p><code>emu.disable_memory_write()</code></p></li>
            <li><p><code>emu.disable_pre_instruction()</code></p></li>
            <li><p><code>emu.disable_post_instruction()</code></p></li>
            <li><p><code>emu.disable_winapi_call()</code></p></li>
            <li><p><code>emu.spawn_console()</code></p></li>
            <li><p><code>emu.spawn_console_at(exp: u64)</code></p></li>
            <li><p><code>emu.spawn_console_at_addr(addr: u64)</code></p></li>
            <li><p><code>emu.update_ldr_entry_base(libname: &amp;str, base: u64)</code></p></li>
        </ul>
        <p>From rust you can also modify directly the Config structure, example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
            emu.cfg.arguments = "--exe_sample_some_arg".to_string();
            emu.cfg.shellcode = true;
        </code></pre>
      </figure>
      </p>
      <p>Find here all the configs available in<a href="https://docs.rs/libmwemu/0.23.5/libmwemu/config/struct.Config.html" about="_blank">Config</a> object.</p>
      <p>But main configs has function wrappers in the main <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/emu/struct.Emu.html" target="_blank">Emu</a> base object.</a></p>
      <p>You can also create a Config object and set it to the emulator with <code>emu.set_config(cfg: Config)</code> but normaly is more convinien to access to emul.cfg as seen above.</p>
    </section>

    <section id="libmaps">
      <h2>Configuring Maps Folder</h2>
      <p>In most of cases you will need to load all the Windows OS simulation part, to have all the PEB+TEB+LDR
        linked-list doing windows Process Simulation.</p>
      <p>For doing this you can use <code>emu.set_maps_folder(folder:str)</code></p>
      <p>If you are going to emulate pure assembly, with no api calls, and no access to windows structures, you don't
        need to load the maps.</p>
      <p>Example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut emu = emu64();
emu.set_maps_folder("/home/sha0/src/mwemu/maps/maps64/");
emu.init_logger();
        </code></pre>
      </figure>
      </p>
      <p>Note that this need to have the maps, so git clone the repo:</p>
      <p>
      <figure class="shell-block">
        <figcaption>Shell</figcaption>
        <pre><code>
❯❯❯ git clone https://github.com/sha0coder/mwemu.git 
                </code></pre>
      </figure>
      </p>
      <p>This call configure the path, but don't load it for now!</p>
      <p>Later we will use one of those 3 to trigger the win32 simulator:</p>
      <ul>
            <li><p><code>emu.load_code(file: &amp;str)</code> if it's PE or shellcode will call internally init_win32</p></li>
            <li><p><code>emu.init_win32(clear_registers: bool, clear_flags: bool)</code> you can trigger directly the win32 simulation, but don't call it twice.</p></li>
      </ul>
      <p>So, if you need the maps and win32 stuff but you don't do load_sample, then you will need to call directly the <code>init_win32</code></p>
    </section>

    <section id="libload">
      <h2>loading ELF, PE, or shellcodes</h2>
      <p>In most of cases you will need to load a sample, from file or from vector.</p>
      <p>Load your main sample with one of these methods, and only once.</p>
      <p>For loading aditional maps, use the load/allocation methods that are explained later.</p>
      <ul>
        <li>
          <p><code>emu.load_code(filename: &amp;str)</code> load the sample to be emulated.</p>
        </li>
        <li>
          <p><code>emu.load_code_bytes(opcodes: &amp;[u8])</code> if you have the bytes already on a variable.</p>
        </li>
      </ul>

      <p>Example1:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
emu.load_code("/samples/sample.bin");
        </code></pre>
      </figure>
      </p>
      <p>Example2:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut opcodes: Vec&lt;u8&gt; = Vec::new();
... // fill the opcodes
let mut emu = emu32();
emu.set_maps_folder("/home/sha0/src/mwemu/maps/maps64/");
emu.load_code_bytes(&amp;opcodes);
emu.init_win32(false, false);
        </code></pre>
      </figure>
      </p>
      <p>Example3:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut emu = emu32();
emu.load_code_bytes(&amp;opcodes);
emu.init_linux64();  // load_code("sample") would trigger init_win32 or init_linux64 depending on file format. 
                     // but with no load_code we must trigger manually the init if we need it.
        </code></pre>
      </figure>
      </p>
      <p>It detects if it's ELF, PE and otherwise is a shellcode.</p>
      <p>In the case of PE or shellcode the win32 simulation is initialized automatically.</p>
      <p>In the case of ELF the linux64 simulation is initialized automatically.</p>
      <p>But if for any reason you don't use load_code() and you need the windows simulator with peb/ldr/dlls loaded on the memory, you need to call init_win32 (even for 64bits, it will detect the arch)</p>
      <p>And if you dont use load_binary() but you need the linux simulator with libc etc loaded, use init_linux64. Note that linux implementation is very basic and only for static 64bits</p>
      <p>Note that calling init_win32() requires previously to have done load_maps to set the maps folder.</p>
    </section>

    <section id="libbuffers">
      <h2>Creating Buffers</h2>
      <p>You can load sections from disk to the emulator's virtual memory, and also can allocate buffers.</p>
      <ul>
            <li><p><code>emu.alloc(map_name: &amp;str, size: u64, permission: Permission) -&gt; u64</code> simplest way to alloc a buffer, it returns the address.</p></li>
            <li><p><code>emu.maps.alloc(sz: u64) -&gt; Option&lt;u64&gt;</code> this is used by the winapi and linux syscalls, this just find a free block of size sz, but don't allocate it, you need then to do emu.maps.create_map</p></li>
            <li><p><code>emu.maps.create_map(name: &amp;str, base: u64, size: u64, permission: Permission</p> create an empty map at specific location.</li>
            <li><p><code>emu.free(map_name: &amp;str);</code> deallocate by map name.</p></li>
            <li><p><code>emu.maps.dealloc(addr: u64);</code> deallocate by address.</p></li>
            <li><p><code>emu.link_library(filepath: &smp;str) -&gt; u64</code> dynamic link a custom dll to the LDR struct.</p></li>
      </ul>

      <p>Example1:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
use libmwemu::maps::mem64::Permission;
use libmwemu::emu32;
...
let ptr_encoded = emu.alloc("enc", 1024, Permission::READ_WRITE_EXECUTE);
let ptr_decoded = emu.alloc("dec", 1024, Permission::READ_WRITE_EXECUTE);
emu.maps.write_bytes(ptr_encoded, &amp;data);
let rax = emu.call64(decoder_func_addr, &amp;[ptr_encoded, ptr_decoded]);
        </code></pre>
      </figure>
      </p>

      <p>Example2:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let addr = emu.maps.alloc(1024);
let map = emu
            .maps
            .create_map("section_memorydump", addr, 1024, Permission::READ_WRITE_EXECUTE)
            .expect("load_map out of memory");
map.load("dumped_section.bin");
        </code></pre>
      </figure>
      </p>
      <p>map is a <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/maps/mem64/struct.Mem64.html" target="_blank">Mem64</a> object, and it has multiple methods. But for most of cases <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/emu/struct.Emu.html" target="_blank">emu</a> and <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/maps/struct.Maps.html" about="_blank">emu.maps</a> methods are enoguth.</p>
    </section>

    <section id="libregisters">
      <h2>Registers</h2>
      <p>You can view the register values and modify it in any moment.</p>
      <p>For instance to prepare the context previous to the emulation, preparing an emulation state.</p>
      <ul>
      <p><h3>Reading a 64bits register or bigger is very direct</h3></p>
          <il><p><code>let rax = emu.regs().rax;</code></p></il>
          <il><p><code>let rip = emu.regs().rip;</code></p></il>
          <il><p><code>let xmm15 = emu.regs().xmm15;</code></p></il>
          <p><h3>Settings a 64bits register or bigger is very direct.</h3></p> 
          <il><p><code>emu.regs_mut().rax = 0x123;</code></p></il>
          <il><p><code>emu.regs_mut().rip = 0x4012312;</code></p></il>
          <il><p><code>emu.regs_mut().xmm15 = 0x11223344_11223344_11223344_11223344u128;</code></p></il>
      <p><h3>Getters for non 64bits (it return always u64 type)</h3></p>
          <il><p><code>let eax = emu.regs().get_eax() as u32;</code></p></il>
          <il><p><code>let eip = emu.regs().get_eip() as u32;</code></p></il>
          <il><p><code>let al = emu.regs().get_eip() as u8;</code></p></il>
      <p><h3>Setters for non 64bits (provide always u64 type)</h3></p>
          <il><p><code>emu.regs_mut().set_eax(123u8);</code></p></il>
          <il><p><code>emu.regs_mut().set_eip(0x123123);</code></p></il>
          <il><p><code>emu.regs_mut().set_al(0xff);</code></p></il>
          <il><p><code>emu.regs_mut().set_sil(0xff);</code></p></il>
          <il><p><code>emu.regs_mut().set_dil(0xff);</code></p></il>
      <p><h3>r1 to r15</h3></p>
          <il><p><code>let r15 = emu.regs().r15();</code></p></il>
          <il><p><code>let n = emu.regs().get_r12w();</code></p></il>
          <il><p><code>emu.regs_mut().set_r8h(0x00);</code></p></il>
          <il><p><code>emu.regs_mut().set_r8l(0xff);</code></p></il>
          <il><p><code>emu.regs_mut().r8 = 0;</code></p></il>
          <il><p><code>let lower_32bits = emu.regs().set_r8d();</code></p></il>
          <il><p><code>let upper_32bits = emu.regs().set_r8u();</code></p></il>
      </ul>
      <p>Regs64 is fully featured, there are also some uncommon registers like ymm, cr, gs, fs, tr and msr.</p>
      <ul>
        <p><h3>helper methods</h3></p>
          <il><p><code>emu.regs_mut().clear::&lt;u8&gt;();</code> clear the lower byte of all the registers.</p></il>
          <il><p><code>emu.regs_mut().rand();</code> randomize register values.</p></il>
          <il><p><code>emu.regs().print::&lt;u32&gt;();</code> print main registers.</p></il>
      </ul>
      <p>And there are much more stuff, for more check the <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/regs64/struct.Regs64.html" target="_blank">Regs64</a> object.</p>
      <p>Note that you can change <code>emu.regs_mut().set_eip(addr);<code> but most of times what you really need is <code>emu.set_eip(addr);</code> which emulates the jmp logic triggering WinAPI if the address is a lib.</p>
    </section>

    <section id="libmemory">
      <h2>Memory operations</h2>
      <p>It could be useful for pinpoint the emulation state before starting the emulation, but other option is checking the memory after the emulation or altering it during the emulation.</p>
      <p>Note that this read/write are inside the emulation virtual memory.</p>
      <ul>
         <p><h3>memory read</h3></p>
            <li><p><code>emu.maps.read_byte(addr: u64) -&gt; Option&lt;u8&gt;</code></p></li>
            <li><p><code>emu.maps.read_f64(addr: u64) -&gt; Option&lt;f64&gt;</code></p></li>
            <li><p><code>emu.maps.read_f32(addr: u64) -&gt; Option&lt;f32&gt;</code></p></li>
            <li><p><code>emu.maps.read_128bits_be(addr: u64) -&gt; Option&lt;u128&gt;</code></p></li>
            <li><p><code>emu.maps.read_128bits_le(addr: u64) -&gt; Option&lt;u128&gt;</code></p></li>
            <li><p><code>emu.maps.read_qword(addr: u64) -&gt; Option&lt;u64&gt;</code></p></li>
            <li><p><code>emu.maps.read_dword(addr: u64) -&gt; Option&lt;u32&gt;</code></p></li>
            <li><p><code>emu.maps.read_word(addr: u64) -&gt; Option&lt;u16&gt;</code></p></li>
            <li><p><code>emu.maps.read_buffer(from: u64, sz: usize) -&gt; Vec&lt;u8&gt;</code></p></li>
            <li><p><code>emu.maps.read_bytes(addr: u64, sz: usize) -&gt; &amp;[u8]</code></p></li>
            <li><p><code>emu.maps.read_bytes_option(addr: u64, sz: usize) -&gt; Option&lt;&amp;[u8]&gt;</code></p></li>
            <li><p><code>emu.maps.read_string_of_bytes(addr: u64, sz: usize) -&gt; String</code></p></li>
            <li><p><code>emu.maps.read_string(addr: u64) -&gt; String</code></p></li>
            <li><p><code>emu.maps.read_wide_string_nocrash(addr: u64) -&gt; String</code></p></li>
            <li><p><code>emu.maps.read_wide_string(addr: u64) -&gt; String</code></p></li>
            <li><p><code>emu.maps.read_wide_string_n(addr: u64, max_chars: usize) -&gt; String</code></p></li>

         <p><h3>memory write</h3></p>
            <li><p><code>emu.maps.write_byte(addr: u64, value: u8) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.write_qword(addr: u64, value: u64) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.write_dword(addr: u64, value: u32) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.write_word(addr: u64, value: u16) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.write_bytes(addr: u64, data: Vec&lt;u8&gt;) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.write_string(to: u64, from: &amp;str)</code></p></li>
            <li><p><code>emu.maps.write_wide_string(to: u64, from: &amp;str)</code></p></li>
            <li><p><code>emu.maps.write_buffer(to: u64, from: &amp;[u8])</code></p></li>
            <li><p><code>emu.maps.write_spaced_bytes(addr: u64, sbs: &amp;str) -&gt; bool</code></p></li>

          <p><h3>libc style memory operations:</h3></p>
            <li><p><code>emu.maps.memset(addr: u64, b: u8, amount: usize)</code></p></li>
            <li><p><code>emu.maps.memcpy(to: u64, from: u64, size: usize) -&gt; bool</code></p></li>
            <li><p><code>emu.maps.sizeof_wide(unicode_str_ptr: u64) -&gt; usize</code></p></li>

          <p><h3>search methods:</h3></p>
            <li><p><code>emu.maps.search_string(kw: &amp;str, map_name: &amp;str) -&gt; Option&lt;Vec&lt;u64&gt;&gt;</code></p></li>
            <li><p><code>emu.maps.search_spaced_bytes_from(sbs: &amp;str, saddr: u64) -&gt; u64</code></p></li>
            <li><p><code>emu.maps.search_spaced_bytes_from_bw(spaced_bytes: &amp;str, start_address: u64) -&gt; u64</code></p></li>
            <li><p><code>emu.maps.search_spaced_bytes(sbs: &amp;str, map_name: &amp;str) -&gt; Vec&lt;u64&gt;</code></p></li>
            <li><p><code>emu.maps.search_spaced_bytes_in_all(sbs: &amp;str) -&gt; Vec&lt;u64&gt;</code></p></li>
            <li><p><code>emu.maps.search_string_in_all(kw: String)</code></p></li>
            <li><p><code>emu.maps.search_bytes(bkw: Vec&lt;u8&gt;, map_name: &amp;str) -&gt; Vec&lt;u64&gt;</code></p></li>
      </ul>

      <p>Examples of preparing context previous to start emulation:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut some_data_structure_needed: Vec<u8> = Vec::new();
load_blob_from_disk("blob.bin", &amp;mut some_data_structure_needed);

let mut emu = libmwemu::emu32();
let addr = emu.alloc("struct1", some_data_structure_needed.len());
emu.maps.write_bytes(addr, some_data_structure_needed);
let rax = emu.call32(0x40323, &amp;[addr, some_data_structure_needed.len()]);
        </code></pre>
      </figure>
      </p>
      <p>Another example:</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut emu = libmwemu::emu32();
let addr = emu.alloc("buff1", 100);
emu.maps.write_string(addr, "Hello MWEMU!");
let text = emu.maps.read_string(addr, 12);
println!("{}", text);

// Write dword
let buffer_addr = emu.alloc("buff2", 4);
emu.maps.write_dword(buffer_addr + 0x100, 0x12345678);
let value = emu.maps.read_dword(buffer_addr + 0x100);
println!("dword: 0x{:x}", value);

// emulate some opcodes
let buff = emu.alloc("code_blob", 1024);
let opcodes = vec![0x90, 0x90, 0x90, 0xc3]; // nop nop nop ret
emu.maps.write_buffer(buff, opcodes);
emu.regs_mut().set_eip(buff);
emu.run(Some(buff+3));
println!("eip: 0x{:x}", emu.regs().get_eip());
// just an example, probalby more convinient using emu.load_code_bytes(&amp;opcodes) for emulating shellcode that is in a variable.
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="libstart">
      <h2>Start Emulation</h2>
      <p>Once everything is configured, you can start the emulation.</p>
      <ul>
          <p><h3>You can start the mulation using run functions</h3></p>
            <li><p><code>emu.run(end_addr: Option&lt;u64&gt;) -&gt; Result&lt;u64, MwemuError&gt;</code></p></li>
            <li><p><code>emu.run_until_ret() -&gt; Result&lt;u64, MwemuError&gt;</code></p></li>
            <li><p><code>emu.run_to(end_pos: u64) -&gt; Result&lt;u64, MwemuError&gt;</code></p></li>
            <li><p><code>emu.run_multi_threaded(end_addr: Option&lt;u64&gt;) -&gt; Result&lt;u64, MwemuError&gt;</code></p></li>
            <li><p><code>emu.run_single_threaded(end_addr: Option&lt;u64&gt;) -&gt; Result&lt;u64, MwemuError&gt;</code></p></li>
            <li><p><code>emu.stop()</code></p></li>

          <p><h3>But this ways is wide more confortable because mimics calling conventions.</h3></p>
            <li><p><code>emu.call32(addr: u64, args: &amp;[u32]) -&gt; Result&lt;u32, MwemuError&gt;</code> microsoft 32bits calling convention.</p></li>
            <li><p><code>emu.call64(addr: u64, args: &amp;[u64]) -&gt; Result&lt;u64, MwemuError&gt;</code> microsoft 64bits calling convention.</p></li>
            <li><p><code>emu.linux_call64(addr: u64, args: &amp;[u64]) -&gt; Result&lt;u64, MwemuError&gt;</code> ABI SysV AMD64 calling conventionused on linux64 user space.</p></li>

          <p><h3>For more control but slow way you can use step, but note that also can use hooks.</h3></p>
            <li><p><code>emu.step() -&gt; bool</code></p></li>
            <li><p><code>emu.step_single_threaded() -&gt; bool</code></p></li>
            <li><p><code>emu.step_multi_threaded() -&gt; bool</code></p></li>
      </ul>


      <h3>Additional Useful Methods</h3>
      <p>Other helpful stuff for emulation control:</p>
      <ul>
          <li><p><code>emu.pos</code> this is the emulated instruction counter, you can access even modify it.</p></li>
          <li><p><code>emu.set_verbose(n: u32)</code> set verbose 0 for go faster to a specific point and then set 2 to view the asm only in that pos ranges.</p></li>
          <li><p><code>emu.cfg.console_enabled = true</code> enable the console autospawn.</p></li>
          <li><p><code>emu.spawn_console()</code> in specific case spawn the console to inspect manually the situation.</p></li>
      </ul>
      <p>
      <figure class="shell-block">
        <figcaption>emu.rs</figcaption>
        <pre><code>
fn main() {
    let mut emu = limwemu::emu64();
    emu.init_logger();
    emu.load_code("/bin/ls.static");
    emu.cfg.console_enabled = true;
    emu.run(None).unwrap();
    emu.spawn_console();
}
        </code></pre>
      </figure>
      </p>
      <p>
      <figure class="shell-block">
        <figcaption>emu.rs</figcaption>
        <pre><code>
let mut emu = libmwemu::emu64();
let vm_buff = emu.alloc("buff", 1024, Permission::READ_WRITE_EXECUTE);
let vm: Vec<u8> = vec![
    0x17, 0xC6, 0x04, 0x4D, 0xFF,
    0x10, 0x5C, 0x3D, 0x86, 0x09,
    0xC9, 0x30, 0xAC, 0x42, 0x05,
    0x59, 0x8C, 0x21, 0x07, 0xD2,
];

emu.load_code_bytes(&amp;shellcode);
let decoder = 0x3c000;
emu.call64(decoder, &amp;[&amp;vm_buff]);
          </code></pre>
        </figure>
        </p>
        <p>
        <p>
      <figure class="shell-block">
        <figcaption>emu.rs</figcaption>
        <pre><code>
fn main() {
    let mut emu = limwemu::emu64();
    emu.init_logger();
    emu.load_code("/bin/ls.static");
    emu.cfg.console_enabled = true;
    emu.run(None).unwrap();
    emu.spawn_console();
}
        </code></pre>
      </figure>
      </p>

    </section>


    <section id="libstack">
      <h2>Stack operations</h2>
      <p>There are methods for altering the stack, note that you also could do with <code>emu.maps</code> writes.</p>
      <p>But with this meethods you trigger all the stack logic, also incrementing rsp/esp.</p>
      <ul>
            <li><p><code>stack_push32(value: u32) -&gt; bool</code></p></li>
            <li><p><code>stack_push64(value: u53) -&gt; bool</code></p></li>
            <li><p><code>stack_pop32() -&gt; Option&lt;u32&gt;</code></p></li>
            <li><p><code>stack_pop64() -&gt; Option&lt;u64&gt;</code></p></li>
      </ul>

      <p>This example simulates a stack based calling convention, but note that you can also use call32() and call64() and linux_call64() methods.</p>
      <p>
      <figure class="shell-block">
        <figcaption>emu.rs</figcaption>
        <pre><code>
loop {
    emu.maps.memset(str_buff, 0, 1024);
    emu.maps.memset(str_decoded, 0, 1024);
    emu.regs_mut().set_eip(decrypt_strings_func);
    emu.stack_push32(i);
    emu.stack_push32(str_buff as u32);
    emu.stack_push32(thread_ctx as u32);
    emu.stack_push32(ret_addr as u32);
    emu.run(Some(ret_addr)).unwrap();
    ...
}
              </code></pre>
      </figure>
      </p>
    </section>

    <section id="libbp">
      <h2>Breakpoints</h2>
      <p>Like a debugger you can configure different types of breakpoints, but the implementation is simple, but are other ways of trigger the emulation to stop.</p>
      <ul>
            <li><p><code>emu.bp.show()</code></p></li>
            <li><p><code>emu.bp.clear_bp()</code></p></li>
            <li><p><code>emu.bp.add_bp(addr: u64)</code></p></li>
            <li><p><code>emu.bp.addr.clone()</code> get a vector of address based breakpoints.</p></li>
            <li><p><code>emu.bp.add_bp_instruction(ins: u64)</code></p></li>
            <li><p><code>emu.bp.instruction.clone()</code></p></li>
            <li><p><code>emu.bp.add_bp_mem_read(addr: u64)</code></p></li>
            <li><p><code>emu.bp.mem_read_addr.clone()</code></p></li>
            <li><p><code>emu.bp.add_bp_mem_write(addr: u64)</code></p></li>
            <li><p><code>emu.bp.mem_write_addr.clone()</code></p></li>
      </ul>
      <p>For more info check <a href="https://docs.rs/libmwemu/0.23.5/libmwemu/breakpoint/struct.Breakpoint.html" target="_blank">Breakpoint</a> object reference.</p>

    </section>

    <section id="libmemdump">
      <h2>Memory dump</h2>
      <p>there are several ways do do a memory dump</p>
      <ul>
          <li><p><code>emu.maps.save_all_allocs(path: &amp;str)</code> only save to disk allocations done by the emulated code.</p></li>
          <li><p><code>emu.maps.save(addr: u64, size: u64, filename: String)</code> dump specific blob to disk.</p></li>
      </ul>
      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
emu.maps.print_maps()
emu.maps.save(0x40324234, 1024, "/tmp/blob.bin")
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="libview">
      <h2>View info</h2>
      <p>There are some less used methods to fetch different type of information.</p>
      <ul>
            <li><p><code>
let mut output = String::new();
self.emu
    .formatter
    .format(&amp;self.emu.instruction.unwrap(), &amp;mut output);
                </code>get last emulated mnemonic.</p></li>


            <li><p><code>emu.pos = 0;</code> reset the emulated instruction count to zero.</p></li>
            <li><p><code>emu.cfg.is_64bits</code> detect in which mode is the emulator.</p></li>
            <li><p><code>emu.disassemble(addr: u64, amount: u32) -&gt; String</code> dissassemble bytes.</p></li>
            <li><p><code>emu.maps.print_maps()</code> print all the maps (allocs, linked dlls, etc)</p></li>
            <li><p><code>emu.maps.print_maps_keyword(kw: &amp;str)</code> print the maps that contain a keyword.</p> </li>
            <li><p><code>
let base = match emu.maps.get_addr_base(addr) {
    Some(v) =&gt; Ok(v),
    None =&gt; ...,
};
            </code></p></li>
            <li><p><code>emu.maps.is_mapped(addr: u64) -&gt; bool</code> check if an address is allocated.</p></li>
            <li><p><code>emu.maps.get_addr_name(addr: u64) -&gt; String</code> get in which map name is the address.</p></li>
            <li><p><code>emu.maps.dump(addr: u64)</code> print bytes.</p></li>
            <li><p><code>emu.maps.dump_n(addr: u64, amount: u64)</code> print n bytes.</p></li>
            <li><p><code>emu.maps.dump_qwords(addr: u64, n: u64)</code> print a list of qwords.</p></li>
            <li><p><code>emu.maps.dump_dwords(addr: u64, n: u64)</code> print a list of dwords.</p></li>
            <li><p><code>emu.maps.size() -&gt; usize</code> show the total allocated memory.</p></li>
            <li><p><code>emu.maps.overlaps(addr: u64, sz: u64) -&gt; bool</code> check if a memory block overlaps with existing map.</p></li>
            <li><p><code>emu.maps.show_allocs()</code> print all the allocations done by the emulated code.</p></li>
            <li><p><code>emu.maps.mem_test() -&gt; bool</code> do a automatic memory test to look for map overlapps.</p></li>
            <li><p><code>emu.api_addr_to_name(addr: u64) -&gt; String</code> provide an address pointing to an API and will fetch the API name.</p></li>
            <li><p><code>emu.api_name_to_addr(name: &amp;str) -&gt; u64</code> get the address of an api name.</p></li>
      </ul>

      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let name = emu.api_addr_to_name(0x11223344)
println!("{}", name)
   MessageBoxA
        </code></pre>
      </figure>
      </p>
    </section>

    <section id="libchbits">
      <h2>Switch architecture bits.</h2>
      <p>There are methods for changing from 32bits to 64bits and vice versa.</p>
      <ul>
            <li><p><code>set_64bits()</code></p></li>
            <li><p><code>set_32bits()</code></p></li>
            <li><p><code>inspect_seq(s: str)</code></p></li>
      </ul>
      <p>But better don't change the architecture on the fly, re-instantiate the emulation object like:</p>
      <p>Example</p>
      <p>
      <figure class="shell-block">
        <figcaption>main.rs</figcaption>
        <pre><code>
let mut emu = libmwemu::emu64();
...
let mut emu = libmwemu::emu32();
        </code></pre>
      </figure>
      </p>
      <p>Or even create both objtects.</p>
    </section>

    <!--
    <section id="libexamples">
      <h2>Real case examples.</h2>
      <p>Find some examples here:</p>
      <p><a href="https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples/scripts">https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples/scripts</a></p>
      <p>And some jupyter nobebooks here:</p>
      <p><a href="https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples">https://github.com/sha0coder/mwemu/tree/main/crates/pymwemu/examples</a></p>
    </section>
    -->

  </div>
</body>

</html>
